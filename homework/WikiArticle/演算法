[<p><b>演算法</b>（<span lang="en">algorithm</span>），在<a class="mw-redirect" href="/wiki/%E6%95%B8%E5%AD%B8" title="數學">數學</a>（<a href="/wiki/%E7%AE%97%E5%AD%B8" title="算學">算學</a>）和<a class="mw-redirect" href="/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" title="電腦科學">電腦科學</a>之中，為任何一系列良定義的具體計算步驟<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup>，常用於<a class="mw-redirect" href="/wiki/%E8%A8%88%E7%AE%97" title="計算">計算</a>、<span class="ilh-all" data-foreign-title="Data processing" data-lang-code="en" data-lang-name="英語" data-orig-title="數據處理"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E6%95%B8%E6%93%9A%E8%99%95%E7%90%86&amp;action=edit&amp;redlink=1" title="資料處理（頁面不存在）">資料處理</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Data_processing" title="en:Data processing"><span dir="auto" lang="en">Data processing</span></a></span>）</span></span>和<a href="/wiki/%E8%87%AA%E5%8A%A8%E6%8E%A8%E7%90%86" title="自動推理">自動推理</a>。作為一個<span class="ilh-all" data-foreign-title="Effective method" data-lang-code="en" data-lang-name="英語" data-orig-title="有效方法"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95&amp;action=edit&amp;redlink=1" title="有效方法（頁面不存在）">有效方法</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Effective_method" title="en:Effective method"><span dir="auto" lang="en">Effective method</span></a></span>）</span></span>，演算法被用於計算<a class="mw-redirect" href="/wiki/%E5%87%BD%E6%95%B8" title="函式">函式</a><sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup>，它包含了一系列定義清晰的指令<sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>，並可於<a class="extiw" href="https://zh.wiktionary.org/wiki/Special:Search/%E6%9C%89%E9%99%90%E7%9A%84" title="wikt:Special:Search/有限的">有限的</a>時間及空間內清楚的表述出來<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup>。
</p>, <p>演算法中的指令描述的是一個<a class="mw-redirect" href="/wiki/%E8%A8%88%E7%AE%97" title="計算">計算</a>，當其<span class="ilh-all" data-foreign-title="Execution (computing)" data-lang-code="en" data-lang-name="英語" data-orig-title="執行"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E5%9F%B7%E8%A1%8C&amp;action=edit&amp;redlink=1" title="執行（頁面不存在）">執行</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Execution_(computing)" title="en:Execution (computing)"><span dir="auto" lang="en">Execution (computing)</span></a></span>）</span></span>時能從一個初始狀態和初始輸入（可能爲<a class="mw-redirect" href="/wiki/%E7%A9%BA%E5%AD%97%E5%85%83%E4%B8%B2" title="空字元串">空</a>）開始，<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup>經過一系列<b>有限</b><sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup>而清晰定義的狀態最終產生<b>輸出</b><sup class="reference" id="cite_ref-7"><a href="#cite_note-7">[7]</a></sup>並<b>停止</b>於一個終態。一個狀態到另一個狀態的轉移不一定是<a href="/wiki/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%AE%97%E6%B3%95" title="確定性演算法">確定的</a>。包括<a class="mw-redirect" href="/wiki/%E9%9A%A8%E6%A9%9F%E5%8C%96%E7%AE%97%E6%B3%95" title="隨機化演算法">隨機化演算法</a>在內的一些演算法，都包含了一些隨機輸入。<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup><sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup>
</p>, <p>早在嘗試解決<a href="/wiki/%E5%A4%A7%E5%8D%AB%C2%B7%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9" title="大衛·希爾伯特">希爾伯特</a>提出的<a href="/wiki/%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7" title="可判定性">判定問題</a>時，關於演算法的一個不完全的概念已經初步定型，並在其後的正式化階段中嘗試定義「<span class="ilh-all" data-foreign-title="Effective calculability" data-lang-code="en" data-lang-name="英語" data-orig-title="有效可計算性"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E6%9C%89%E6%95%88%E5%8F%AF%E8%A8%88%E7%AE%97%E6%80%A7&amp;action=edit&amp;redlink=1" title="有效可計算性（頁面不存在）">有效可計算性</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Effective_calculability" title="en:Effective calculability"><span dir="auto" lang="en">Effective calculability</span></a></span>）</span></span><sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup>」或者「<span class="ilh-all" data-foreign-title="Effective method" data-lang-code="en" data-lang-name="英語" data-orig-title="有效方法"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95&amp;action=edit&amp;redlink=1" title="有效方法（頁面不存在）">有效方法</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Effective_method" title="en:Effective method"><span dir="auto" lang="en">Effective method</span></a></span>）</span></span><sup class="reference" id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup>」。這些嘗試包括<a href="/wiki/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94" title="庫爾特·哥德爾">庫爾特·哥德爾</a>、<a href="/wiki/%E9%9B%85%E5%85%8B%C2%B7%E5%9F%83%E5%B0%94%E5%B8%83%E6%9C%97" title="雅克·埃爾布朗">雅克·埃爾布朗</a>和<a href="/wiki/%E6%96%AF%E8%92%82%E8%8A%AC%C2%B7%E7%A7%91%E5%B0%94%C2%B7%E5%85%8B%E8%8E%B1%E5%B0%BC" title="史蒂芬·科爾·克萊尼">史蒂芬·科爾·克萊尼</a>分別於1930年、1934年和1935年提出的<a class="mw-redirect" href="/wiki/%E9%81%9E%E6%AD%B8_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" title="遞迴 (計算機科學)">遞迴函式</a>，<a href="/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87" title="阿隆佐·邱奇">阿隆佐·邱奇</a>於1936年提出的<a href="/wiki/%CE%9B%E6%BC%94%E7%AE%97" title="Λ演算">λ演算</a>，1936年<span class="ilh-all" data-foreign-title="Emil Leon Post" data-lang-code="en" data-lang-name="英語" data-orig-title="埃米爾·萊昂·珀斯特"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E5%9F%83%E7%B1%B3%E7%88%BE%C2%B7%E8%90%8A%E6%98%82%C2%B7%E7%8F%80%E6%96%AF%E7%89%B9&amp;action=edit&amp;redlink=1" title="埃米爾·萊昂·珀斯特（頁面不存在）">埃米爾·萊昂·珀斯特</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Emil_Leon_Post" title="en:Emil Leon Post"><span dir="auto" lang="en">Emil Leon Post</span></a></span>）</span></span>的<a href="/wiki/%E6%B3%A2%E6%96%AF%E7%89%B9-%E5%9B%BE%E7%81%B5%E6%9C%BA" title="波斯特-圖靈機">Formulation 1</a>和<a class="mw-redirect" href="/wiki/%E8%89%BE%E5%80%AB%C2%B7%E5%9C%96%E9%9D%88" title="艾倫·圖靈">艾倫·圖靈</a>1937年提出的<a class="mw-redirect" href="/wiki/%E5%9C%96%E9%9D%88%E6%A9%9F" title="圖靈機">圖靈機</a>。即使在當下，依然常有符合直覺的想法難以定義爲形式化演算法的情況。<sup class="reference" id="cite_ref-12"><a href="#cite_note-12">[12]</a></sup>
</p>, <p>演算法在中國古代文獻中稱為「術」，最早出現在《<a href="/wiki/%E5%91%A8%E9%AB%80%E7%AE%97%E7%B6%93" title="周髀算經">周髀算經</a>》、《<a href="/wiki/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%9C%AF" title="九章算術">九章算術</a>》。特別是《九章算術》，給出<a href="/wiki/%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97" title="四則運算">四則運算</a>、<a class="mw-redirect" href="/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0" title="最大公約數">最大公約數</a>、最小公倍數、開<a href="/wiki/%E5%B9%B3%E6%96%B9%E6%A0%B9" title="平方根">平方根</a>、開<a href="/wiki/%E7%AB%8B%E6%96%B9%E6%A0%B9" title="立方根">立方根</a>、求<a href="/wiki/%E7%B4%A0%E6%95%B0" title="素數">素數</a>的<a href="/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95" title="埃拉托斯特尼篩法">埃拉托斯特尼篩法</a>，線性方程組求解的演算法。三國時代的<a href="/wiki/%E5%88%98%E5%BE%BD" title="劉徽">劉徽</a>給出求圓周率的演算法：<a class="mw-redirect" href="/wiki/%E5%88%98%E5%BE%BD%E5%89%B2%E5%9C%86%E6%9C%AF" title="劉徽割圓術">劉徽割圓術</a>。
</p>, <p>自唐代以來，歷代更有許多專門論述「算法」的專著：
</p>, <p>而英文名稱「algorithm」來自於9世紀<a href="/wiki/%E6%B3%A2%E6%96%AF" title="波斯">波斯</a>數學家<a href="/wiki/%E8%8A%B1%E6%8B%89%E5%AD%90%E7%B1%B3" title="花拉子米">花拉子米</a>（比阿勒·霍瓦里松，波斯語：<span lang="fa">خوارزمی </span>‎，拉丁轉寫：al-Khwarizmi），因為比阿勒·霍瓦里松在<a href="/wiki/%E6%95%B0%E5%AD%A6" title="數學">數學</a>上提出了演算法這個概念。「演算法」原為「algorism」，即「al-Khwarizmi」的音轉，意思是「<a href="/wiki/%E8%8A%B1%E6%8B%89%E5%AD%90%E7%B1%B3" title="花拉子米">花拉子米</a>」的運演算法則，在18世紀演變為「algorithm」。
</p>, <p><a class="mw-redirect" href="/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95" title="歐幾里得演算法">歐幾里得演算法</a>被人們認為是史上第一個演算法。
</p>, <p>第一次編寫程式是<a href="/wiki/%E6%84%9B%E9%81%94%C2%B7%E5%8B%92%E8%8A%99%E8%95%BE%E7%B5%B2" title="愛達·勒芙蕾絲">愛達·勒芙蕾絲</a>（<span lang="en">Ada Byron</span>）於1842年為<a class="mw-redirect" href="/wiki/%E5%B7%B4%E8%B4%9D%E5%A5%87%E5%88%86%E6%9E%90%E6%9C%BA" title="巴貝奇分析機">巴貝奇分析機</a>編寫求解解<a href="/wiki/%E4%BC%AF%E5%8A%AA%E5%88%A9%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B" title="伯努利微分方程">伯努利微分方程</a>的<a class="mw-disambig" href="/wiki/%E7%A8%8B%E5%BA%8F" title="程式">程式</a>，因此愛達·勒芙蕾絲被大多數人認為是世界上第一位<a href="/wiki/%E7%A8%8B%E5%BA%8F%E5%91%98" title="程式設計師">程式設計師</a><sup class="reference" id="cite_ref-Lovelace_Google_13-0"><a href="#cite_note-Lovelace_Google-13">[13]</a></sup>。因為<a href="/wiki/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E5%B7%B4%E8%B4%9D%E5%A5%87" title="查爾斯·巴貝奇">查爾斯·巴貝奇</a>（<span lang="en">Charles Babbage</span>）未能完成他的巴貝奇分析機，這個演算法未能在巴貝奇分析機上執行。
</p>, <p>因為「well-defined procedure」缺少數學上精確的定義，19世紀和20世紀早期的數學家、<a href="/wiki/%E9%80%BB%E8%BE%91%E5%AD%A6%E5%AE%B6" title="邏輯學家">邏輯學家</a>在定義演算法上出現了困難。20世紀的<a href="/wiki/%E8%8B%B1%E5%9B%BD" title="英國">英國</a>數學家<a class="mw-redirect" href="/wiki/%E5%9B%BE%E7%81%B5" title="圖靈">圖靈</a>提出了著名的<a href="/wiki/%E9%82%B1%E5%A5%87%EF%BC%8D%E5%9B%BE%E7%81%B5%E8%AE%BA%E9%A2%98" title="邱奇－圖靈論題">圖靈論題</a>，並提出一種假想的<a class="mw-redirect" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA" title="電腦">電腦</a>的抽象模型，這個模型被稱為<a href="/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA" title="圖靈機">圖靈機</a>。圖靈機的出現解決了演算法定義的難題，圖靈的思想對演算法的發展起到了重要的作用。
</p>, <p>以下是<a href="/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3" title="高德納">高德納</a>在他的著作《<a href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF" title="電腦程式設計藝術">電腦程式設計藝術</a>》裡對演算法的特徵歸納：
</p>, <p>演算法的核心是建立問題抽象的模型和明確求解目標，之後可以根據具體的問題選擇不同的模式和方法完成演算法的設計。
</p>, <p>完全<a class="new" href="/w/index.php?title=%E9%81%8D%E6%AD%B7%E6%B3%95&amp;action=edit&amp;redlink=1" title="遍歷法（頁面不存在）">遍歷法</a>和不完全遍歷法：在問題的解是有限離散解空間，且可以驗證正確性和最佳性時，最簡單的演算法就是把解空間的所有元素完全遍歷一遍，逐個檢測元素是否是我們要的解。這是最直接的演算法，實現往往最簡單。但是當解空間特別龐大時，這種演算法很可能導致工程上無法承受的計算量。這時候可以利用不完全遍歷方法——例如各種搜尋法和規劃法——來減少計算量。
</p>, <p><a href="/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" title="分治法">分治法</a>：把一個問題分割成互相獨立的多個部分分別求解的思路。這種求解思路帶來的好處之一是便於進行平行計算。
</p>, <p><a href="/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" title="動態規劃">動態規劃</a>法：當問題的整體最佳解就是由局部最佳解組成的時候，經常採用的一種方法。
</p>, <p><a class="mw-redirect" href="/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95" title="貪婪法">貪婪演算法</a>：常見的近似求解思路。當問題的整體最佳解不是（或無法證明是）由局部最佳解組成，且對解的最佳性沒有要求的時候，可以採用的一種方法。
</p>, <p><a href="/wiki/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92" title="線性規劃">線性規劃</a>法：見條目。
</p>, <p>簡併法：把一個問題通過邏輯或數學推理，簡化成與之等價或者近似的、相對簡單的模型，進而求解的方法。
</p>, <p><a href="/wiki/%E9%80%92%E5%BD%92" title="遞迴">遞迴方法</a>與<a href="/wiki/%E8%BF%AD%E4%BB%A3" title="疊代">疊代方法</a>
</p>, <p>順序計算、<a href="/wiki/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97" title="平行計算">平行計算</a>和<a href="/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97" title="分散式計算">分散式計算</a>：順序計算就是把形式化演算法用程式語言進行單執行緒序列化後執行。
</p>, <p>確定性演算法和非確定性演算法
</p>, <p>精確求解和近似求解
</p>, <p>演算法是電腦處理資訊的本質，因為電腦程式本質上是一個演算法來告訴電腦確切的步驟來執行一個指定的任務，如計算職工的薪水或列印學生的成績單。一般地，當演算法在處理資訊時，會從<a href="/wiki/%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87" title="輸入裝置">輸入裝置</a>或資料的儲存位址讀取資料，把結果寫入<a href="/wiki/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87" title="輸出裝置">輸出裝置</a>或某個儲存位址供以後再呼叫。
</p>, <p>演算法的<a href="/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" title="時間複雜度">時間複雜度</a>是指演算法需要消耗的時間資源。一般來說，電腦演算法是問題規模<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span>的函式<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(n)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle f(n)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c1c49fad1eccc4e9af1e4f23f32efdc3ac4da973" style="vertical-align: -0.838ex; width:4.483ex; height:2.843ex;"/></span>，演算法的時間複雜度也因此記做
</p>, <p>演算法執行時間的增長率與<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(n)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle f(n)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c1c49fad1eccc4e9af1e4f23f32efdc3ac4da973" style="vertical-align: -0.838ex; width:4.483ex; height:2.843ex;"/></span>的增長率正相關，稱作<span class="ilh-all" data-foreign-title="Asymptotic computational complexity" data-lang-code="en" data-lang-name="英語" data-orig-title="渐近时间复杂度"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E6%B8%90%E8%BF%91%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;action=edit&amp;redlink=1" title="漸近時間複雜度（頁面不存在）">漸近時間複雜度</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Asymptotic_computational_complexity" title="en:Asymptotic computational complexity"><span dir="auto" lang="en">Asymptotic computational complexity</span></a></span>）</span></span>，簡稱時間複雜度。
</p>, <p>常見的時間複雜度有：常數階<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(1)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(1)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(1)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21" style="vertical-align: -0.838ex; width:4.745ex; height:2.843ex;"/></span>，對數階<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(\log n)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(\log n)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d" style="vertical-align: -0.838ex; width:8.336ex; height:2.843ex;"/></span>，線性階<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(n)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a" style="vertical-align: -0.838ex; width:4.977ex; height:2.843ex;"/></span>，線性對數階<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n\log n)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(n\log n)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1" style="vertical-align: -0.838ex; width:10.118ex; height:2.843ex;"/></span>，平方階<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n^{2})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n^{2})}</annotation>
</semantics>
</math></span><img alt="O(n^{2})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6cd9594a16cb898b8f2a2dff9227a385ec183392" style="vertical-align: -0.838ex; width:6.032ex; height:3.176ex;"/></span>，立方階<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n^{3})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n^{3})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(n^{3})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6b04f5c5cfea38f43406d9442387ad28555e2609" style="vertical-align: -0.838ex; width:6.032ex; height:3.176ex;"/></span>，...，<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle k}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>k</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle k}</annotation>
</semantics>
</math></span><img alt=" k " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" style="vertical-align: -0.338ex; width:1.211ex; height:2.176ex;"/></span>次方階<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n^{k})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n^{k})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(n^{k})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1247a36dbf5f27981eb76f42c2848931af165029" style="vertical-align: -0.838ex; width:6.066ex; height:3.176ex;"/></span>,指數階<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(2^{n})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(2^{n})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(2^{n})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d4b1a4ff0bc4f81ebf79f28260c6fb54ee08ff8d" style="vertical-align: -0.838ex; width:5.964ex; height:2.843ex;"/></span>。隨著問題規模<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span>的不斷增大，上述時間複雜度不斷增大，演算法的執行效率越低。
</p>, <p>演算法的<a class="mw-redirect" href="/wiki/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" title="空間複雜度">空間複雜度</a>是指演算法需要消耗的空間資源。其計算和表示方法與時間複雜度類似，一般都用複雜度的<a class="new" href="/w/index.php?title=%E6%B8%90%E8%BF%91%E6%80%A7&amp;action=edit&amp;redlink=1" title="漸近性（頁面不存在）">漸近性</a>來表示。同時間複雜度相比，空間複雜度的分析要簡單得多。
</p>, <p>演算法不單單可以用電腦程式來實現，也可以在<a href="/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" title="人工神經網路">人工神經網路</a>、<a class="mw-redirect" href="/wiki/%E7%94%B5%E8%B7%AF" title="電路">電路</a>或者<a href="/wiki/%E6%9C%BA%E6%A2%B0" title="機械">機械</a>裝置上實現。
</p>, <p>這是演算法的一個簡單的例子。
</p>, <p>我們有一串隨機<a href="/wiki/%E6%95%B0%E5%88%97" title="數列">數列</a>。我們的目的是找到這個數列中最大的數。如果將數列中的每一個數字看成是一顆豆子的大小，可以將下面的演算法形象地稱為「撿豆子」：
</p>, <p>以上演算法在中國大陸的教科書中通常被叫做「打擂法」或者「迴圈打擂」<sup class="reference" id="cite_ref-14"><a href="#cite_note-14">[14]</a></sup><sup class="reference" id="cite_ref-15"><a href="#cite_note-15">[15]</a></sup><sup class="reference" id="cite_ref-16"><a href="#cite_note-16">[16]</a></sup>：在一個for迴圈中，每輪迴圈都有新的挑戰者。若挑戰者勝的話，挑戰者做新擂主，否則擂主衛冕。for迴圈結束後輸出最後的擂主。
</p>, <p>下面是一個形式演算法，用<a href="/wiki/C%E8%AF%AD%E8%A8%80" title="C語言">ANSI C</a>代碼表示
</p>, <p>求兩個自然數的<a class="mw-redirect" href="/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0" title="最大公約數">最大公約數</a>
設兩個變數<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle M}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>M</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle M}</annotation>
</semantics>
</math></span><img alt="M" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd" style="vertical-align: -0.338ex; width:2.442ex; height:2.176ex;"/></span>和<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle N}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>N</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle N}</annotation>
</semantics>
</math></span><img alt="N" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3890c981ae85503089652feb48b191b57aae3" style="vertical-align: -0.338ex; width:2.064ex; height:2.176ex;"/></span>
</p>, <p>用<a href="/wiki/C%E8%AF%AD%E8%A8%80" title="C語言">ANSI C</a>代碼表示
</p>, <p>利用if函式以及遞迴則能做出更為精簡的程式碼，更可省去交換的麻煩。（但是也因為遞迴呼叫，其空間複雜度提高）
</p>]