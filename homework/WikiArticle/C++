[<p><b>C++</b>是一種被廣泛使用的電腦程式設計語言。它是一種通用<a class="mw-redirect" href="/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E8%AA%9E%E8%A8%80" title="程式設計語言">程式設計語言</a>，支援<a href="/wiki/%E5%A4%9A%E9%87%8D%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F" title="多重程式設計範式">多重程式設計模式</a>，例如<a class="mw-redirect" href="/wiki/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" title="程序化程式設計">程序化程式設計</a>、<a href="/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" title="抽象化 (計算機科學)">資料抽象化</a>、<a class="mw-redirect" href="/wiki/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" title="物件導向程式設計">物件導向程式設計</a>、<a class="mw-redirect" href="/wiki/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" title="泛型程式設計">泛型程式設計</a>和<a href="/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" title="設計模式 (電腦)">設計模式</a>等。
</p>, <p><a class="mw-redirect" href="/wiki/%E6%AF%94%E9%9B%85%E5%B0%BC%C2%B7%E6%96%AF%E7%89%B9%E5%8B%9E%E6%96%AF%E7%89%B9%E9%AD%AF%E6%99%AE" title="比雅尼·斯特勞斯特魯普">比雅尼·斯特勞斯特魯普</a>博士在<a href="/wiki/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4" title="貝爾實驗室">貝爾實驗室</a>工作期間在20世紀80年代發明並實現了C++。起初，這種語言被稱作「<span lang="en">C with Classes</span>」（「包含『<a href="/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="類 (電腦科學)">類</a>』的C語言」），作為<a class="mw-redirect" href="/wiki/C%E8%AA%9E%E8%A8%80" title="C語言">C語言</a>的增強版出現。隨後，C++不斷增加新特性。<a href="/wiki/%E8%99%9A%E5%87%BD%E6%95%B0" title="虛擬函式">虛擬函式</a>（<span lang="en">virtual function</span>）、<a href="/wiki/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" title="運算子多載">運算子多載</a>（<span lang="en">operator overloading</span>）、<a href="/wiki/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" title="多重繼承">多繼承</a>（<span lang="en">multiple inheritance</span>）、<a href="/wiki/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93" title="標準模板庫">標準模板庫</a>（<span lang="en">standard template library</span>, <span lang="en">STL</span>）、<a href="/wiki/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" title="例外處理">例外處理</a>（<span lang="en">exception</span>）、<a class="mw-redirect" href="/wiki/RTTI" title="RTTI">執行時型別</a>資訊（<span lang="en">Runtime type information</span>）、<a href="/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" title="命名空間">命名空間</a>（<span lang="en">namespace</span>）等概念逐漸納入標準。1998年，<a class="mw-redirect" href="/wiki/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87" title="國際標準化組織">國際標準組織</a>（<span lang="en">ISO</span>）頒布了C++程式設計語言的第一個國際標準ISO/IEC 14882:1998，目前最新標準為ISO/IEC 14882:2017。根據《C++編程思想》（<span lang="en"><i>Thinking in C++</i></span>）一書，C++與C的代碼執行效率往往相差在±5%之間<sup class="reference" id="cite_ref-invention3_1-0"><a href="#cite_note-invention3-1">[1]</a></sup>。
</p>, <p>C++語言發展大概可以分為三個階段：第一階段從80年代到1995年。這一階段C++語言基本上是傳統類型上的<a href="/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" title="物件導向程式設計">物件導向</a>語言，並且憑藉著接近C語言的效率，在工業界使用的開發語言中佔據了相當大份額；第二階段從1995年到2000年，這一階段由於<a class="mw-redirect" href="/wiki/%E6%A8%99%E6%BA%96%E6%A8%A1%E6%9D%BF%E5%BA%AB" title="標準模板庫">標準模板庫</a>（<span lang="en">STL</span>）和後來的<a href="/wiki/Boost_C%2B%2B_Libraries" title="Boost C++ Libraries">Boost</a>等程式庫的出現，<a class="mw-redirect" href="/wiki/%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" title="泛型程式設計">泛型程式設計</a>在C++中佔據了越來越多的比重。當然，同時由於<a href="/wiki/Java" title="Java">Java</a>、<a class="mw-redirect" href="/wiki/C%EF%BC%83" title="C＃">C#</a>等語言的出現和硬體價格的大規模下降，C++受到了一定的衝擊；第三階段從2000年至今，由於以<a class="new" href="/w/index.php?title=Loki&amp;action=edit&amp;redlink=1" title="Loki（頁面不存在）">Loki</a>、<a href="/wiki/Boost_C%2B%2B_Libraries" title="Boost C++ Libraries">MPL(Boost)</a>等程式庫為代表的<a class="new" href="/w/index.php?title=%E7%94%A2%E7%94%9F%E5%BC%8F%E7%B7%A8%E7%A8%8B&amp;action=edit&amp;redlink=1" title="產生式程式設計（頁面不存在）">產生式程式設計</a>和<a class="mw-redirect" href="/wiki/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%B7%A8%E7%A8%8B" title="模板元程式設計">模板元程式設計</a>的出現，C++出現了發展歷史上又一個新的高峰，這些新技術的出現以及和原有技術的融合，使C++已經成為當今主流程式設計語言中最複雜的一員。
</p>, <p><a class="mw-redirect" href="/wiki/%E6%AF%94%E9%9B%85%E5%B0%BC%C2%B7%E5%8F%B2%E7%89%B9%E5%8B%9E%E6%96%AF%E7%89%B9%E9%AD%AF%E6%99%AE" title="比雅尼·史特勞斯特魯普">比雅尼·史特勞斯特魯普</a>（<span lang="en">Stroustrup</span>）工作起於1979年的<span lang="en"><i>C with Classes</i></span>。這個構思起源於史特勞斯特魯普做博士論文時的一些程式撰寫經驗。他發現<a href="/wiki/Simula" title="Simula">Simula</a>具備很利於大型軟體開發的特點，但<span lang="en">Simula</span>的執行速度太慢，無法對現實需求發揮功效；<a href="/wiki/BCPL" title="BCPL">BCPL</a>雖快得多，但它過於低階的特性，使其不適於大型軟體的開發。當史特勞斯特魯普開始在<a href="/wiki/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4" title="貝爾實驗室">貝爾實驗室</a>工作時，他有分析<a class="mw-redirect" href="/wiki/Unix" title="Unix">UNIX</a><a class="mw-disambig" href="/wiki/%E6%A0%B8%E5%BF%83" title="核心">核心</a>關於<a class="mw-redirect" href="/wiki/%E5%88%86%E6%95%A3%E5%BC%8F%E8%A8%88%E7%AE%97" title="分散式計算">分散式計算</a>的問題。回想起他的博士論文經驗，史特勞斯特魯普開始為C語言增強一些類似<span lang="en">Simula</span>的特點<sup class="reference" id="cite_ref-evolving_2-0"><a href="#cite_note-evolving-2">[2]</a></sup>。之所以選擇C，是因為它適於各種用途、快速和可移植性。除了<a href="/wiki/C" title="C">C</a>和<a href="/wiki/Simula" title="Simula">Simula</a>之外，同時也從其它語言中取得靈感，如<a href="/wiki/ALGOL_68" title="ALGOL 68">ALGOL 68</a>、<a href="/wiki/Ada" title="Ada">Ada</a>、<a href="/wiki/CLU" title="CLU">CLU</a>以及<a class="mw-disambig" href="/wiki/ML" title="ML">ML</a>。
</p>, <p>剛開始時，<a href="/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="類 (電腦科學)">類別</a>、<a href="/wiki/%E7%BB%A7%E6%89%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="繼承 (電腦科學)">衍生類別</a>、儲存類型檢查、<a class="new" href="/w/index.php?title=%E5%85%A7%E8%81%AF&amp;action=edit&amp;redlink=1" title="內聯（頁面不存在）">內聯</a>和<a href="/wiki/%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" title="預設參數">預設參數</a>特性，都是透過<a class="new" href="/w/index.php?title=Cfront&amp;action=edit&amp;redlink=1" title="Cfront（頁面不存在）">Cfront</a>引入C語言之中<sup class="reference" id="cite_ref-hopl2_3-0"><a href="#cite_note-hopl2-3">[3]</a></sup>。
</p>, <p>1983年，<span lang="en">C with Classes</span>改命名為C++（<code>++</code>是C語言中的<a href="/wiki/%E5%A2%9E%E5%80%BC%E5%92%8C%E5%87%8F%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6" title="增值和減值運算子">增值運算子</a>）。加入了新的特性，其中包括<a class="mw-redirect" href="/wiki/%E8%99%9B%E6%93%AC%E5%87%BD%E5%BC%8F" title="虛擬函式">虛擬函式</a>、函式名和運算子多載、參考、常數、使用者可控制的自由空間儲存區控制、改良的型別檢查，以及新的雙斜線（<code>//</code>）單行註解風格。
</p>, <p>1985年，發布第一版《C++程式設計語言》，提供一個重點的語言參考，至此還不是官方標準<sup class="reference" id="cite_ref-1st-edition3_4-0"><a href="#cite_note-1st-edition3-4">[4]</a></sup>。1985年10月出現了第一個商業化發布。
</p>, <p>1989年，發布了<span lang="en">Release 2.0</span>。引入了多重繼承、抽象類別、靜態成員函式、<a class="new" href="/w/index.php?title=%E5%B8%B8%E6%95%B8%E6%88%90%E5%93%A1%E5%87%BD%E5%BC%8F&amp;action=edit&amp;redlink=1" title="常數成員函式（頁面不存在）">常數成員函式</a>，以及成員保護。1990年，出版了<i>The Annotated C++ Reference Manual</i>。這本書後來成為標準化的基礎。稍後還引入了<a href="/wiki/%E6%A8%A1%E6%9D%BF_(C%2B%2B)" title="模板 (C++)">模板</a>、<a class="mw-redirect" href="/wiki/%E4%BE%8B%E5%A4%96%E8%99%95%E7%90%86" title="例外處理">例外處理</a>、<a href="/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" title="命名空間">命名空間</a>、新的<a class="new" href="/w/index.php?title=%E5%BC%B7%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&amp;action=edit&amp;redlink=1" title="強制型別轉換（頁面不存在）">強制型別轉換</a>，以及<a class="mw-redirect" href="/wiki/%E5%B8%83%E7%88%BE_(%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B)" title="布爾 (資料類型)">布林</a>型別。
</p>, <p>隨著C++語言的演變，也逐漸演化出相應的標準程式庫。最先加進C++標準函式庫的是串流<span lang="en">I/O</span>程式庫，其用以取代傳統的C函式，如<a class="mw-redirect" href="/wiki/Printf" title="Printf">printf</a>和<a class="mw-redirect" href="/wiki/Scanf" title="Scanf">scanf</a>。隨後所引入的程式庫中最重要的便是<a class="mw-redirect" href="/wiki/%E6%A8%99%E6%BA%96%E6%A8%A1%E6%9D%BF%E5%BA%AB" title="標準模板庫">標準模板庫</a>，簡稱<a class="mw-disambig" href="/wiki/STL" title="STL">STL</a>。
</p>, <p>多年後，一個聯合的<a class="mw-redirect" href="/wiki/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%AD%A6%E4%BC%9A" title="美國國家標準學會">ANSI</a>-<a class="mw-redirect" href="/wiki/International_Organization_for_Standardization" title="International Organization for Standardization">ISO</a>委員會於1998年對C++標準化（<i><a class="mw-redirect" href="/wiki/ISO/IEC_14882" title="ISO/IEC 14882">ISO/IEC 14882</a>：1998</i>）。在官方釋出1998標準的若干年後，委員會處理缺陷報告，並於2003年發布一個C++標準的修正版本。2005年，一份名為<b><a href="/wiki/C%2B%2B_Technical_Report_1" title="C++ Technical Report 1">Library Technical Report 1</a></b>（簡稱<span lang="en">TR1</span>）的技術報告釋出。雖然還不是官方標準的一部分，不過它所提供的幾個擴展可望成為下一版C++標準的一部分。幾乎所有目前仍在維護的C++編譯器皆已支援<span lang="en">TR1</span>。
</p>, <p>目前最新的C++標準是2017年12月發布的<i><a class="mw-redirect" href="/wiki/ISO/IEC_14882" title="ISO/IEC 14882">ISO/IEC 14882</a>:2017</i><sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup>，又稱<a href="/wiki/C%2B%2B17" title="C++17">C++17</a>或<a class="new" href="/w/index.php?title=C%2B%2B1z&amp;action=edit&amp;redlink=1" title="C++1z（頁面不存在）">C++1z</a>。
</p>, <p>雖然C++免專利，但標準檔案本身並不是免費的，儘管標準文件不是免費的，但是很容易從網路中取得，最簡單的就是C++標準文件之前的最後一次草稿版本，它與標準的差別幾乎只在於排版上。
</p>, <p>C++這個名字是Rick Mascitti於1983年中所建議的，並於1983年12月首次使用。更早以前，尚在研究階段的發展中語言曾被稱為「<span lang="en">new C</span>」，之後是「<span lang="en">C with Classes</span>」。在<a class="mw-redirect" href="/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" title="電腦科學">電腦科學</a>中，C++仍被稱為C語言的上層結構。它最後得名於C語言中的「++」運算子（其對<a href="/wiki/%E8%AE%8A%E6%95%B8" title="變數">變數</a>的值進行遞增）。而且在共同的命名約定中，使用「+」以表示增強的程式。史特勞斯特魯普說：「這個名字象徵著源自於C語言變化的自然演進」。<span class="ilh-all" data-foreign-title="ABCL/c+" data-lang-code="en" data-lang-name="英語" data-orig-title="ABCL/c+"><span class="ilh-page"><a class="new" href="/w/index.php?title=ABCL/c%2B&amp;action=edit&amp;redlink=1" title="ABCL/c+（頁面不存在）">C+</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/ABCL/c%2B" title="en:ABCL/c+"><span dir="auto" lang="en">ABCL/c+</span></a></span>）</span></span>是一個和C/C++無關的早期程式語言。
</p>, <p>Rick Mascitti在1992年被非正式地問起名字的由來，他表示這是在半開玩笑中說出的。他從沒想過C++會成為這門語言的正式名字。
</p>, <p>有一個關於C++名字的笑話是，當你使用後綴++時，附加只發生在運算之後（因此，它應該是++C，而不是C++，這個笑話是說時下某些程式設計師還在以使用C的方式使用C++，這通常被一些權威著作認為是不正確的）。
</p>, <p>由<span lang="en">ISO/IEC JTC1/SC22/WG21</span>進行。已經出版的標準文件如下：
</p>, <p>在《C++語言的設計和演化》（1994）中，<span lang="en">Bjarne Stroustrup</span>描述了他在設計C++時，所使用的一些原則。知道這些原則有助於理解C++為何會是現在這個樣子。以下總結了一些原則，詳盡的內容可參閱《C++語言的設計和演化》：
</p>, <p>1998的C++<a class="new" href="/w/index.php?title=Standardization&amp;action=edit&amp;redlink=1" title="Standardization（頁面不存在）">標準</a>分為兩個部分：<a href="/wiki/%E6%A0%B8%E5%BF%83%E8%AA%9E%E8%A8%80" title="核心語言">核心語言</a>和<a class="mw-redirect" href="/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E7%A8%8B%E5%BC%8F%E5%BA%AB" title="C++標準程式庫">C++標準程式庫</a>；後者包含了大部分<a class="mw-redirect" href="/wiki/%E6%A8%99%E6%BA%96%E6%A8%A1%E6%9D%BF%E5%BA%AB" title="標準模板庫">標準模板庫</a>和C標準程式庫的稍加修改版本。存在許多不屬於標準部分的C++程式庫，且使用外部連結，程式庫甚至可以用<a href="/wiki/C" title="C">C</a>撰寫。
</p>, <p><a class="mw-redirect" href="/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E7%A8%8B%E5%BC%8F%E5%BA%AB" title="C++標準程式庫">C++標準程式庫</a>充分吸收了C標準程式庫，並佐以少許的修改，使其與C++良好的運作。另一個大型的程式庫部分，是以<a class="mw-redirect" href="/wiki/%E6%A8%99%E6%BA%96%E6%A8%A1%E6%9D%BF%E5%BA%AB" title="標準模板庫">標準模板庫</a>（<span lang="en">STL</span>）為基礎，<span lang="en">STL</span>於1994年2月正式成為ANSI/ISO C++。它提供了實用的工具，如<a class="mw-redirect" href="/wiki/%E5%AE%B9%E5%99%A8_(%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)" title="容器 (抽象資料型別)">容器類</a>（如：<a class="mw-redirect" href="/wiki/Array" title="Array">Array</a>和<span lang="en">Vector</span>），<a href="/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8" title="疊代器">疊代器</a>（廣義<a href="/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" title="指標 (電腦科學)">指標</a>）提供容器以類似陣列的存取方式，以及<a class="mw-redirect" href="/wiki/%E6%BC%94%E7%AE%97%E6%B3%95" title="演算法"><u>泛型</u>演算法</a>進行搜尋和排序的運算。此外還提供了(multi)map和(multi)set，它們都共享相似的成員函式。因此，以下成為可能，使用模板撰寫泛型演算法，它可以和任何容器或在任何以疊代器定義的序列上運作。如同C，使用<code>#include</code><a class="new" href="/w/index.php?title=Directive_(programming)&amp;action=edit&amp;redlink=1" title="Directive (programming)（頁面不存在）">指令</a>包含<a class="new" href="/w/index.php?title=%E6%A8%99%E6%BA%96%E8%A1%A8%E9%A0%AD&amp;action=edit&amp;redlink=1" title="標準表頭（頁面不存在）">標準表頭</a>，即可存取<a class="mw-redirect" href="/wiki/%E7%A8%8B%E5%BC%8F%E5%BA%AB" title="程式庫">程式庫</a>裡的功能。C++提供69個標準表頭，其中19個不再贊成使用。
</p>, <p>使用標準模板庫（例如：使用<code>std::vector</code>或<code>std::string</code>來取代C風格的陣列或字元陣列）有助於導向更安全和更靈活的軟體。
</p>, <p>在<a class="mw-disambig" href="/wiki/STL" title="STL">STL</a>在納入C++標準以前，是來自<a class="mw-redirect" href="/wiki/Hewlett-Packard" title="Hewlett-Packard">HP</a>和後來的<a class="mw-redirect" href="/wiki/Silicon_Graphics" title="Silicon Graphics">SGI</a>的第三方程式庫，標準中並未稱之為「<span lang="en">STL</span>」，它只是標準庫中的一部分，但仍有許多人使用這個名稱，以別於其它的標準庫（輸入／輸出串流、國際化、診斷、C程式庫子集，等等）。
另外，如<code>std::basic_string</code>此類標準委員會添加的介面，有時也被誤認為<span lang="en">STL</span>；實際上它們並不存在於原始的<span lang="en">SGI STL</span>中，在標準化後<span lang="en">SGI STL</span>才從標準庫吸收加入其中。
</p>, <p>和C語言相比，C++引入了更多的特性，包括：複合型別（參照類型等）、<span lang="en">const</span>限定符和<span lang="en">constexpr</span>常數表達式、型別處理運算子（型別別名及<span lang="en">auto</span>和<span lang="en">decltype</span>等多種型別指示符）、C++標準庫（<span lang="en">IO</span>庫與多種容器類）與疊代器、動態記憶體與智慧型指標、函式重載、物件導向程式設計（如資料抽象化、成員函式、類作用域、建構函式與解構函式、靜態成員、存取控制與繼承、虛擬函式、抽象類與介面等）、拷貝控制、運算子多載、造型與函式風格的強制型別轉換、模板與泛型程式設計，以及異常處理、命名空間、多繼承與虛繼承、執行時型別辨識及巢狀類等。
</p>, <p>和普遍認為的相反，C++不是第一個正式引入<code>const</code>關鍵字的語言。80年代早期，<span lang="en">Bjarne Stroustrup</span>和<span lang="en">Dennis Retchie</span>討論之後提供了在C語言中<span lang="en">readonly/writeonly</span>的實現機制，並在帶類的C中取得了一定經驗。關鍵字<code>const</code>正式引入C語言是在<span lang="en">ANSI C89</span>。這早於第一個C++國際標準近十年，但此時<code>const</code>已被C++實現普遍採用。
</p>, <p>C++在某些案例中（見下「與C不相容之處」），進行比C還要多的類型檢查。
</p>, <p>以「<code>//</code>」起始作為註解起源自C的前身<a href="/wiki/BCPL" title="BCPL">BCPL</a>，而後被重新引入到C++。
</p>, <p>C++的一些特性，C不久之後也採用了，包括在<span lang="en">for</span>迴圈的括號中聲明，C++風格的註解（使用<code>//</code>符號，和<code>inline</code>，雖然C99定義的<code>inline</code>關鍵字與C++的定義不相容。不過，<a href="/wiki/C%E8%AF%AD%E8%A8%80#C99" title="C語言">C99</a>也引入了不存在於C++的特性，如：可變參數<a href="/wiki/%E5%B7%A8%E9%9B%86" title="巨集">巨集</a>，和以陣列作為參數的較佳處理；某些C++編譯器可能實作若干特性，以作為擴展，但其餘部分並不符合現存的C++特性）
</p>, <p>一個常見的混淆其實只是一個微妙的術語問題：由於它的演化來自C，在C++中的術語<b><a class="mw-disambig" href="/wiki/%E5%AF%B9%E8%B1%A1" title="物件">物件</a></b>和C語言一樣是意味著<b>記憶體區域</b>，而不是<b>類別的實體</b>，在其它絕大多數的<a class="mw-redirect" href="/wiki/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91" title="物件導向">物件導向</a>語言也是如此。舉例來說，在C和C++中，語句<code>int i;</code>定義一個<code>int</code>型別的物件，這就是變數的值<code>i</code>將在指派時，所存入的記憶體區域。
</p>, <p><code>const</code>是一個C和C++語言的關鍵字，意思是宣告一個常數(不能改變的變數)，即唯讀。使用<code>const</code>在一定程度上可以提高程式的安全性和可靠性，也便於實現對此進行最佳化（如把唯讀物件放入<a class="mw-redirect" href="/wiki/ROM" title="ROM">ROM</a>中）。<code>const</code>作為型別限定符，是型別的一部分。
</p>, <p>以下是和C語言相容的用法：
</p>, <p>但是，<code>const</code>在C++中有更強大的特性。它允許在編譯時確定作為真正的常數表達式。例如，
</p>, <p>此前C語言並不支援這樣的用法，直到<a class="mw-redirect" href="/wiki/C99" title="C99">C99</a>允許用變數作為陣列長度（需要注意的是<a class="mw-redirect" href="/wiki/C99" title="C99">C99</a>中的<span lang="en">VLA</span>支援執行期確定陣列長度，但C++從未支援）。此外，C++中，命名空間作用域的<span lang="en">const</span>物件的名稱隱含內部連結。這意味著直接在標頭檔里定義<span lang="en">const</span>物件被多個原始檔包含時，也不會重定義。
</p>, <p>在C++11及之後的C++標準中，推薦使用擁有更嚴格語意的<code>constexpr</code>限定符來表示一個可以出現在常數表達式中的變數。const可區分為頂層const(top-level const)和底層const(low-level const)。
</p>, <p>實際上，在語意表達方面，const更多表示為「唯讀」，constexpr才表示編譯期常數。
</p>, <p>C++有時被認為是C的<a class="mw-redirect" href="/wiki/%E8%B6%85%E9%9B%86" title="超集">超集</a>（<span lang="en">superset</span>），但這並不嚴謹。
</p>, <p>各個版本的<span lang="en">ISO/IEC 14882</span>的附錄C中都指出了C++和<span lang="en">ISO C</span>的一些不相容之處。
</p>, <p>大部分的C代碼可以很輕易的在C++中正確編譯，但仍有少數差異，導致某些有效的C代碼在C++中失效，或者在C++中有不同的行為。
</p>, <p>最常見的差異之一是，C允許從<code>void*</code>隱式轉換到其它的指標型別，但C++不允許。下列是有效的C代碼：
</p>, <p>但要使其在C和C++<i>兩者</i>皆能運作，就需要使用顯式轉換：
</p>, <p>另一個常見的可移植問題是，C++定義了很多的新關鍵字，如<code>new</code>和<code>class</code>，它們在C程式中，是可以作為識別字（例：變數名）的。
</p>, <p><a class="new" href="/w/index.php?title=C_(programming_language)&amp;action=edit&amp;redlink=1" title="C (programming language)（頁面不存在）">C99</a>去除了一些不相容之處，也新增了一些C++的特性，如<code>//</code>注釋，以及在代碼中混合使用。不過C99也納入幾個和C++衝突的新特性（如：可變長陣列、原生複數型別和複合逐字常數），而C++11已經加入了相容C99預處理器的特性。
</p>, <p>由於C++函式和C函式通常具有不同的<a href="/wiki/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0" title="名字修飾">名字修飾</a>和<a href="/wiki/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A" title="呼叫約定">呼叫約定</a>，所有在C++中呼叫的C函式，須放在<code>extern "C" { /* C函数声明 */ }</code>之內。
</p>, <p>下面這個程式顯示「Hello, world!」然後結束執行：
</p>, <p>這裡也可以使用<span lang="en">using</span>指令以避免再次聲明std::——
</p>, <p>你可以用「\n」代替以上代碼裡的「<span lang="en">endl</span>」，不過必須用在句子的後端。請不要把斜槓（/）和反斜槓（\）混淆。
</p>, <p>但需要知道的是， std::endl 不僅僅會在某個輸出流中插入換行字元，還將執行輸出流的 flush() 函式（即重新整理緩衝區），而'\n'則不會。
</p>, <p><br/>
根據ISO C++的規定，全域<span lang="en">main</span>函式必須返回<span lang="en">int</span>。
以下兩種形式是合法的：
</p>, <p>不過，在一些編譯器（例如<a href="/wiki/Microsoft_Visual_C%2B%2B" title="Microsoft Visual C++">Visual C++</a>）上，
</p>, <p>也是合法的。<b>千萬不要這樣寫，因為這樣的寫法沒有相容性。</b>
</p>, <p>分為
</p>, <p>C++主要有三個編譯階段：預處理、轉譯成目的碼和連結（最後的兩個階段一般才視為真正的「編譯」）。在第一階段，預處理，會將<i>預處理器指令</i>替換成原始碼，然後送到下一個編譯階段。
</p>, <p>預處理指令的運作方式是根據使用者定義的規則，簡單的把記號字元序列置換成其它的記號字元序列。它們進行<a class="new" href="/w/index.php?title=%E5%B7%A8%E9%9B%86%E7%BD%AE%E6%8F%9B&amp;action=edit&amp;redlink=1" title="巨集置換（頁面不存在）">巨集置換</a>、含入其它的檔案（由底層至高階的特性，例如包含模組／包／單元／元件）、條件式編譯和條件式含入。例如：
</p>, <p>原始代碼中出現的<code>PI</code>，都將會替換為<code>3.1415926535897932384626433832795028841971693993751</code>。另一個普遍的例子是
</p>, <p>它將標準庫標頭檔<code>iostream</code>中所有的宣告都納入呼叫者所在的程式塊。除了以上提到的常用指令以外，還有幾個額外的預處理器指令，可以用來控制編譯流程、條件式含入或排除代碼區塊等等。
</p>, <p>模板（<span lang="en">Template</span>）指C++程式語言中的函式模板（<span lang="en">function template</span>）與類別模板（<span lang="en">class template</span>），這種觀念是取材自<a href="/wiki/Simula" title="Simula">Simula</a>的泛型程式設計。它採用<a href="/wiki/Typename" title="Typename">typename</a>和<a class="mw-redirect" href="/wiki/Class" title="Class">class</a>兩個關鍵字，來標識模板類別的型別參數。<a href="/wiki/C%2B%2B11" title="C++11">C++11</a>和<a href="/wiki/C%2B%2B14" title="C++14">C++14</a>分別引入了型別別名模板和變數模板。
</p>, <p>在物件導向物件程式設計術語中，物件（<span lang="en">object</span>）是資料（<span lang="en">data</span>）和處理資料的指令（<span lang="en">instructions</span>）的聯合（<span lang="en">association</span>）。類比（<span lang="en">simulate</span>）實際世界（<span lang="en">real-world</span>），物件有三種特質（<span lang="en">characteristics</span>）：狀態（<span lang="en">State</span>）、行為（<span lang="en">Behavior</span>）、<span class="ilh-all" data-foreign-title="Identity (object-oriented programming)" data-lang-code="en" data-lang-name="英語" data-orig-title="同一性身分"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E5%90%8C%E4%B8%80%E6%80%A7%E8%BA%AB%E5%88%86&amp;action=edit&amp;redlink=1" title="同一性身分（頁面不存在）">同一性身分</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Identity_(object-oriented_programming)" title="en:Identity (object-oriented programming)"><span dir="auto" lang="en">Identity (object-oriented programming)</span></a></span>）</span></span>，並且使用訊息（<span lang="en">message</span>）來引發彼此的互動。類別（<span lang="en">class</span>）為物件的<a href="/wiki/%E8%97%8D%E5%9C%96" title="藍圖">藍圖</a>或工廠，定義了物件的抽象特質，包括物件的屬性特質和物件的行為特質，屬性的值即是物件的狀態，行為即是物件能夠做的事。
</p>, <p>C++為類別構成式物件導向程式設計語言（<span lang="en">class-based object-oriented programming language</span>），類別概念具現化（<span lang="en">reification</span>）地作為二等公民（<span lang="en">second-class citizen</span>）出現在C++語言當中，在語法中明確地使用類別來做到資料抽象化、封裝、模組化、繼承、子型別多型、物件狀態的自動初始化。C++中，一個類別即為一個型別，加上封裝，一個類別即為一個<a href="/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5" title="抽象資料型別">抽象資料型別</a>（<span lang="en">Abstract Data Type</span>，<span lang="en">ADT</span>），繼承、多型、模板都加強了類別的可抽象性。在C++可以使用<span lang="en">class</span>或<span lang="en">struct</span>這兩個關鍵字宣告類別（<span lang="en">class</span>），而使用<span lang="en">new</span>運算子實體化類別產生的實體（<span lang="en">instance</span>）即為物件，是<a href="/wiki/%E7%AC%AC%E4%B8%80%E9%A1%9E%E7%89%A9%E4%BB%B6" title="第一類物件">一等公民</a>。C/C++以資料成員（<span lang="en">data member</span>）表達屬性，以成員函式（<span lang="en">member function</span>）表達行為。
</p>, <p>聲明一個<span lang="en">Car class</span>：
</p>, <p>但是仍然需要注意，嚴格來說，C++中物件的概念和C的對應概念接近，表示的是具有特定型別的儲存，而非物件導向意義上的「物件」：一個物件不一定是類型別的。此外，C++意義上的「實例」僅指模板實例化的結果，而並不指物件。作為對比，<a href="/wiki/Java" title="Java">Java</a>的「物件」和「實例」的概念和這裡的使用一致。
</p>, <p>封裝（<span lang="en">Encapsulation</span>）是將資料和處理資料的<a href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F" title="電腦程式">程式</a>（<span lang="en">procedure</span>）組合起來，僅對外公開介面（<span lang="en">interface</span>），達到資訊隱藏（<span lang="en">information hiding</span>）的功能。封裝的優點是能減少耦合（<span lang="en">Coupling</span>）。C++、<span lang="en">Java</span>、C# 等語言定義物件都是在語法中明確地使用類別（<span lang="en">Class</span>）來做到封裝。
</p>, <p>C++的類別對其成員（包括資料成員、函式成員）分為三種封裝狀態：
</p>, <p>一般可以將C++類的對外介面設定為公有成員；類內部使用的資料、函式設定為私有成員；供衍生自該類別的子類別使用的資料、函式設定為保護成員。
</p>, <p><a class="mw-redirect" href="/wiki/%E7%B9%BC%E6%89%BF_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" title="繼承 (計算機科學)">繼承</a>（<span lang="en">Inheritance</span>）是指衍生類別（<span lang="en">subclass</span>）繼承基礎類別（<span lang="en">superclass</span>），會自動取得超類別除私有特質外的全部特質，同一類別的所有實體都會自動有該類別的全部特質，做到程式碼再用（<span lang="en">reuse</span>）。C++只支援類別構成式繼承，雖然同一類別的所有實體都有該類別的全部特質，但是實體能夠共享的實體成員只限成員函式，類別的任何實體資料成員乃每個實體獨立一份，因此物件間並不能共享狀態，除非特質為參考型別的屬性，或使用指標來間接共享。C++支援的繼承關係為：
</p>, <p>C++支援多繼承（<span lang="en">multiple inheritance</span>，<span lang="en">MI</span>）。多繼承（<span lang="en">multiple inheritance</span>，<span lang="en">MI</span>）的優缺點一直廣為使用者所爭議，許多語言（如<a href="/wiki/Java" title="Java">Java</a>）並不支援多重繼承，而改以單一繼承和介面繼承（<span lang="en">interface inheritance</span>），而另一些語言則採用用單一繼承和混入（<span lang="en">mixin</span>）。C++通過<a href="/wiki/%E8%99%9A%E7%BB%A7%E6%89%BF" title="虛繼承">虛繼承</a>（<span lang="en">Virtual Inheritance</span>）來解決多繼承帶來的一系列問題。
</p>, <p>除了封裝與繼承外，C++還提供了<a class="mw-redirect" href="/wiki/%E5%A4%9A%E5%9E%8B_(%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)" title="多型 (物件導向程式設計)">多型</a>功能，物件導向的精神在於多型（<span lang="en">Polymorphism</span>），一般的多型，是指動態多型，係使用繼承和動態繫結（<span lang="en">Dynamic Binding</span>）實現，使用多型可建立起繼承體系（<span lang="en">Inheritance hierarchy</span>）。類（<span lang="en">class</span>）與繼承只是達成多型中的一種手段，所以稱物件導向而非類別導向。
</p>, <p>多型又分成靜態多型（<span lang="en">Static Polymorphism</span>）與動態多型（<span lang="en">Dynamic Polymorphism</span>）。C++語言支援的動態多型必須結合繼承和動態繫結（<span lang="en">Dynamic Binding</span>）方式實現。靜態多型是指編譯時決定的多型，包括多載和以模板（<span lang="en">template</span>）實現多型的方法即參數化型態（<span lang="en">Parameterized Types</span>），是使用巨集（<span lang="en">macro</span>）的「程式碼膨脹法」達到多型效果。
</p>, <p>型別轉換（<span lang="en">type cast</span>）也是一種非參數化（<span lang="en">ad hoc</span>）多型的概念，C++提供dynamic_cast, static_cast等運算子來實作強制型別轉換（<span lang="en">Coercion</span>）。
</p>, <p>運算元重載（<span lang="en">operator overloading</span>）或函式重載（<span lang="en">function overloading</span>）也算是多型的概念。
</p>, <p><mark class="template-facttext" title="需要提供文獻來源">C/Java/C#都可以用某種 <a href="/wiki/LR%E5%89%96%E6%9E%90%E5%99%A8" title="LR剖析器">LR剖析器</a>（或其變形）分析文法</mark><sup class="noprint Template-Fact"><a href="/wiki/Wikipedia:%E5%88%97%E6%98%8E%E6%9D%A5%E6%BA%90" title="Wikipedia:列明來源"><span style="white-space: nowrap;" title="來源請求開始於2016年9月3日。">[來源請求]</span></a></sup>，但C++是個著名的例外：請看下面的代碼。
</p>, <p>上面的<span lang="en">table1</span>顯然是一個<a href="/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2" title="字串">字串</a>的二維<a href="/wiki/%E6%95%B0%E7%BB%84" title="陣列">陣列</a>，而<span lang="en">table2</span>則未必能通過編譯：如果嚴格遵循<span lang="en">LR</span>分析過程，串 &gt;&gt; 會被解釋為<a class="mw-redirect" href="/wiki/%E7%A7%BB%E4%BD%8D" title="移位">右移</a>運算子而非兩個代表<a href="/wiki/%E6%A8%A1%E6%9D%BF_(C%2B%2B)" title="模板 (C++)">模板</a>參數列結束的右尖括號，因此出現編譯錯誤，必須以<span lang="en">table1</span>的方式用空格區分。(在C++11發布之後，特別規定了當處理模板時，&gt;&gt;被優先視為兩個&gt;，所以table1和table2均可通過編譯.)
</p>, <p>「在這12年裡，C++使用者人數大約每七個月半增加一倍」是許多C++相關檔案必引的一段話；然而，時至今日新語言層出不窮，使用者人數已不太可能以如此速度增長。分析機構<span lang="en">EvansData</span>定期對開發人員展開調查，其資料顯示，以C++為工具的開發人員在整個開發界所佔的比例由1998年春天的76%下降至2004年秋的46%。
</p>, <p>一部分<span lang="en">Unix/C</span>程式設計師對C++語言深惡痛絕，他們批評的理由如下：
</p>, <p>概括說來<a href="/wiki/UNIX" title="UNIX">UNIX</a>程式設計師批評C++主要是由於<span lang="en">UNIX</span>社群與C++社群的文化差異<sup class="reference" id="cite_ref-24"><a href="#cite_note-24">[24]</a></sup>。
</p>, <p>一個值得注意的事情是<a href="/wiki/Linux" title="Linux">Linux</a>之父<a class="mw-redirect" href="/wiki/Linus_Torvalds" title="Linus Torvalds">Linus Torvalds</a>曾經炮轟C++；<a href="/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96" title="圖靈獎">圖靈獎</a>得主<a href="/wiki/%E5%B0%BC%E5%85%8B%E5%8A%B3%E6%96%AF%C2%B7%E7%BB%B4%E5%B0%94%E7%89%B9" title="尼克勞斯·維爾特">尼克勞斯·維爾特</a>也曾經批評C++語言太複雜、語法語意模糊，是「拙劣工程學」的成果。
</p>, <p>事實上，對於C++語言的批評並不只來源於<span lang="en">Unix/Unix-Like</span>系統下的程式設計師。就像C++語言本身是一個跨平台的語言一樣，對C++的批評並不局限於<span lang="en">Unix/Unix-Like</span>系統用戶。
</p>, <p>一個確定的觀點是：C++是一門複雜的語言、這門語言擁有過多的特性從而難以徹底掌握；C++的某些庫難以學習、掌握並應用於實際當中；很多程式設計師都認為C++是一個過度設計的程式語言。<sup class="noprint Template-Fact"><a href="/wiki/Wikipedia:%E5%88%97%E6%98%8E%E6%9D%A5%E6%BA%90" title="Wikipedia:列明來源"><span style="white-space: nowrap;" title="來源請求。">[來源請求]</span></a></sup>
</p>, <p class="mw-empty-elt">
</p>]