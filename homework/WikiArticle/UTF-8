[<p><b>UTF-8</b>（<span lang="en"><b>8-bit Unicode Transformation Format</b></span>）是一種針對<a href="/wiki/Unicode" title="Unicode">Unicode</a>的可變長度<a class="mw-redirect" href="/wiki/%E5%AD%97%E5%85%83%E7%B7%A8%E7%A2%BC" title="字元編碼">字元編碼</a>，也是一種<a class="mw-redirect" href="/wiki/%E5%89%8D%E7%BC%80%E7%A0%81" title="字首碼">字首碼</a>。它可以用一至四個位元組對Unicode字元集中的所有有效編碼點進行編碼，屬於<a href="/wiki/Unicode" title="Unicode">Unicode</a>標準的一部分，最初由<a href="/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A" title="肯·湯普遜">肯·湯普遜</a>和<a class="new" href="/w/index.php?title=%E7%BD%97%E5%B8%83%C2%B7%E6%B4%BE%E5%85%8B&amp;action=edit&amp;redlink=1" title="羅布·派克（頁面不存在）">羅布·派克</a>提出。<sup class="reference" id="cite_ref-:0_2-0"><a href="#cite_note-:0-2">[2]</a></sup><sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>由於較小值的編碼點一般使用頻率較高，直接使用Unicode編碼效率低下，大量浪費記憶體空間。UTF-8就是為了解決向下相容ASCII碼而設計，Unicode中前128個字元（與ASCII碼一一對應），使用與ASCII碼相同的二進位值的單個<a href="/wiki/%E5%AD%97%E8%8A%82" title="位元組">位元組</a>進行編碼，這使得原來處理ASCII字元的<a class="mw-redirect" href="/wiki/%E8%BB%9F%E9%AB%94" title="軟體">軟體</a>無須或只須做少部份修改，即可繼續使用。因此，它逐漸成為<a class="mw-redirect" href="/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6" title="電子郵件">電子郵件</a>、<a href="/wiki/%E7%B6%B2%E9%A0%81" title="網頁">網頁</a>及其他<a href="/wiki/%E5%84%B2%E5%AD%98%E8%A3%9D%E7%BD%AE" title="儲存裝置">儲存</a>或傳送文字優先採用的編碼方式。
</p>, <p>自2009年以來，UTF-8一直是全球資訊網的最主要的編碼形式（對所有，而不僅是Unicode範圍內的編碼）（並由WHATWG宣布為強制性的「適用於所有事物(<span lang="en">for all things</span>)」，<sup class="reference" id="cite_ref-mandatory_4-0"><a href="#cite_note-mandatory-4">[4]</a></sup>截止到2019年11月， 在所有網頁中，UTF-8編碼應用率高達94.3%（其中一些僅是ASCII編碼，因為它是UTF-8的子集），而在排名最高的1000個網頁中占96％。<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup> 第二熱門的多位元組編碼方式Shift JIS和GB 2312分別具有0.3％和0.2％的占有率。<sup class="reference" id="cite_ref-W3Techs_6-0"><a href="#cite_note-W3Techs-6">[6]</a></sup><sup class="reference" id="cite_ref-BuiltWith_7-0"><a href="#cite_note-BuiltWith-7">[7]</a></sup><sup class="reference" id="cite_ref-MarkDavis2012_1-1"><a href="#cite_note-MarkDavis2012-1">[1]</a></sup>Internet郵件聯盟（<span lang="en"> Internet Mail Consortium, IMC</span>）建議所有電子郵件程式都能夠使用UTF-8展示和建立郵件，<sup class="reference" id="cite_ref-IMC_8-0"><a href="#cite_note-IMC-8">[8]</a></sup> W3C建議UTF-8作為XML檔案和HTML檔案的預設編碼方式。<sup class="reference" id="cite_ref-html5charset_9-0"><a href="#cite_note-html5charset-9">[9]</a></sup><a class="mw-redirect" href="/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%B5%84" title="網際網路工程工作小組">網際網路工程工作小組</a>（IETF）要求所有<a class="mw-redirect" href="/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF" title="網際網路">網際網路</a><a class="mw-redirect" href="/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE" title="網路協定">協定</a>都必須支援UTF-8編碼<sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup>。<a class="new" href="/w/index.php?title=%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E8%81%AF%E7%9B%9F&amp;action=edit&amp;redlink=1" title="網際網路郵件聯盟（頁面不存在）">網際網路郵件聯盟</a>（IMC）建議所有電子郵件軟體都支援UTF-8編碼。<sup class="reference" id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup>
</p>, <p>1992年初，為建立良好的<a class="new" href="/w/index.php?title=%E4%BD%8D%E5%85%83%E7%B5%84%E4%B8%B2%E7%B7%A8%E7%A2%BC%E7%B3%BB%E7%B5%B1&amp;action=edit&amp;redlink=1" title="位元組串編碼系統（頁面不存在）">位元組串編碼系統</a>以供多<a href="/wiki/%E5%AD%97%E8%8A%82" title="位元組">位元組</a>字元集使用，開始了一個正式的研究。<a href="/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86" title="通用字元集">ISO/IEC 10646</a>的初稿中有一個非必須的附錄，名為UTF。當中包含了一個供32<a href="/wiki/%E4%BD%8D%E5%85%83" title="位元">位元</a>的<a class="mw-redirect" href="/wiki/UCS" title="UCS">字元</a>使用的位元組串編碼系統。這個編碼方式的效能並不令人滿意，但它提出了將0-127的範圍保留給ASCII以相容舊系統的概念。
</p>, <p>1992年7月，<a href="/wiki/X/Open" title="X/Open">X/Open</a>委員會XoJIG開始尋求一個較佳的編碼系統。<a href="/wiki/Unix%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4" title="Unix系統實驗室">Unix系統實驗室</a>（USL）的Dave Prosser為此提出了一個編碼系統的建議。它具備可更快速實作的特性，並引入一項新的改進。其中，7<a href="/wiki/%E4%BD%8D%E5%85%83" title="位元">位元</a>的<a href="/wiki/ASCII" title="ASCII">ASCII</a>符號只代表原來的意思，所有多位元組序列則會包含第8<a href="/wiki/%E4%BD%8D%E5%85%83" title="位元">位元</a>的符號，也就是所謂的<a class="mw-redirect" href="/wiki/%E6%9C%80%E9%AB%98%E6%9C%89%E6%95%88%E4%BD%8D%E5%85%83" title="最高有效位元">最高有效位元</a>。
</p>, <p>1992年8月，這個建議由<a href="/wiki/IBM" title="IBM">IBM</a><a href="/wiki/X/Open" title="X/Open">X/Open</a>的代表流傳到一些感興趣的團體。與此同時，<a class="mw-redirect" href="/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4" title="貝爾實驗室">貝爾實驗室</a><a href="/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB" title="貝爾實驗室九號計畫">九號計畫</a><a class="mw-redirect" href="/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" title="作業系統">作業系統</a>工作小組的<a href="/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A" title="肯·湯普遜">肯·湯普遜</a>對這編碼系統作出重大的修改，讓編碼可以自我同步，使得不必從字串的開首讀取，也能找出字元間的分界。1992年9月2日，<a href="/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A" title="肯·湯普遜">肯·湯普遜</a>和<a href="/wiki/%E7%BE%85%E5%8B%83%C2%B7%E6%B4%BE%E5%85%8B" title="羅勃·派克">羅勃·派克</a>一起在<a class="mw-redirect" href="/wiki/%E7%BE%8E%E5%9C%8B" title="美國">美國</a><a class="mw-redirect" href="/wiki/%E6%96%B0%E6%BE%A4%E8%A5%BF%E5%B7%9E" title="新澤西州">新澤西州</a>一架餐車的餐桌墊上描繪出此設計的要點。接下來的日子，Pike及湯普遜將它實現，並將這編碼系統完全應用在<a href="/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB" title="貝爾實驗室九號計畫">九號計畫</a>當中，及後他將有關成果回饋X/Open。
</p>, <p>1993年1月25-29日的在<a class="mw-disambig" href="/wiki/%E8%81%96%E5%9C%B0%E7%89%99%E5%93%A5" title="聖地牙哥">聖地牙哥</a>舉行的<a href="/wiki/USENIX" title="USENIX">USENIX</a>會議首次正式介紹UTF-8。
</p>, <p>自1996年起，<a class="mw-redirect" href="/wiki/%E5%BE%AE%E8%BB%9F" title="微軟">微軟</a>的<a href="/wiki/CAB" title="CAB">CAB</a>（MS Cabinet）規格在UTF-8標準正式落實前就明確容許在任何地方使用UTF-8編碼系統。但有關的編碼器實際上從來沒有實作這方面的規格。
</p>, <p>UTF-8使用一至六個<a href="/wiki/%E5%AD%97%E8%8A%82" title="位元組">位元組</a>為每個字元編碼（儘管如此，2003年11月UTF-8被RFC 3629重新規範，只能使用原來Unicode定義的區域，U+0000到U+10FFFF，也就是說最多四個位元組）：
</p>, <p>對上述提及的第四種字元而言，UTF-8使用四至六個位元組來編碼似乎太耗費資源了。但UTF-8對所有常用的字元都可以用三個位元組表示，而且它的另一種選擇，<a href="/wiki/UTF-16" title="UTF-16">UTF-16編碼</a>，對前述的第四種字元同樣需要四個位元組來編碼，所以要決定UTF-8或UTF-16哪種編碼比較有效率，還要視所使用的字元的分布範圍而定。不過，如果使用一些傳統的壓縮系統，比如<a href="/wiki/DEFLATE" title="DEFLATE">DEFLATE</a>，則這些不同編碼系統間的的差異就變得微不足道了。若顧及傳統壓縮演算法在壓縮較短文字上的效果不大，可以考慮使用<a class="new" href="/w/index.php?title=Unicode%E6%A8%99%E6%BA%96%E5%A3%93%E7%B8%AE%E6%A0%BC%E5%BC%8F&amp;action=edit&amp;redlink=1" title="Unicode標準壓縮格式（頁面不存在）">Unicode標準壓縮格式</a>（SCSU）。
</p>, <p>目前有好幾份關於UTF-8詳細規格的檔案，但這些檔案在定義上有些許的不同：
</p>, <p>它們取代了以下那些被淘汰的定義：
</p>, <p>事實上，所有定義的基本原理都是相同的，它們之間最主要的不同是支援的字元範圍及無效輸入的處理方法。
</p>, <p>Unicode<a class="mw-redirect" href="/wiki/UCS" title="UCS">字元</a>的<a href="/wiki/%E4%BD%8D%E5%85%83" title="位元">位元</a>被分割為數個部分，並分配到UTF-8的<a href="/wiki/%E5%AD%97%E8%8A%82" title="位元組">位元組</a>串中較低的<a href="/wiki/%E4%BD%8D%E5%85%83" title="位元">位元</a>的位置。在U+0080的以下<a class="mw-redirect" href="/wiki/UCS" title="UCS">字元</a>都使用內含其字元的單<a href="/wiki/%E5%AD%97%E8%8A%82" title="位元組">位元組</a>編碼。這些編碼正好對應7位元的ASCII字元。在其他情況，有可能需要多達4個字元組來表示一個字元。這些多位元組的<a class="mw-redirect" href="/wiki/%E6%9C%80%E9%AB%98%E6%9C%89%E6%95%88%E4%BD%8D%E5%85%83" title="最高有效位元">最高有效位元</a>會設定成1，以防止與7位元的ASCII字元混淆，並保持標準的位元組主導字串運作順利。
</p>, <p>例如，希伯來語字母aleph（א）的Unicode代碼是U+05D0，按照以下方法改成UTF-8：
</p>, <p>所以開始的128個字元（US-ASCII）只需一位元組，接下來的1920個字元需要雙位元組編碼，包括帶<a href="/wiki/%E9%99%84%E5%8A%A0%E7%AC%A6%E5%8F%B7" title="附加符號">附加符號</a>的<a href="/wiki/%E6%8B%89%E4%B8%81%E5%AD%97%E6%AF%8D" title="拉丁字母">拉丁字母</a>，<a href="/wiki/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D" title="希臘字母">希臘字母</a>，<a href="/wiki/%E8%A5%BF%E9%87%8C%E5%B0%94%E5%AD%97%E6%AF%8D" title="西里爾字母">西里爾字母</a>，<a href="/wiki/%E7%A7%91%E6%99%AE%E7%89%B9%E8%AF%AD" title="科普特語">科普特語</a>字母，<a href="/wiki/%E4%BA%9A%E7%BE%8E%E5%B0%BC%E4%BA%9A%E8%AF%AD" title="亞美尼亞語">亞美尼亞語</a>字母，<a class="mw-redirect" href="/wiki/%E5%B8%8C%E4%BC%AF%E6%9D%A5%E6%96%87" title="希伯來文">希伯來文</a>字母和<a href="/wiki/%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D" title="阿拉伯字母">阿拉伯字母</a>的字元。<a class="mw-redirect" href="/wiki/%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A8%AE%E5%B9%B3%E9%9D%A2" title="基本多文種平面">基本多文種平面</a>中其餘的字元使用三個位元組，剩餘字元使用四個位元組。
</p>, <p>根據這種方式可以處理更大數量的字元。原來的規範允許長達6位元組的序列，可以覆蓋到31位元（<a href="/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86" title="通用字元集">通用字元集</a>原來的極限）。儘管如此，2003年11月UTF-8被RFC 3629重新規範，只能使用原來Unicode定義的區域，U+0000到U+10FFFF。根據這些規範，以下位元組值將無法出現在合法UTF-8序列中：
</p>, <p>因此，對UTF-8編碼中的任意位元組，根據第一位，可判斷是否為ASCII字元；根據前二位，可判斷該位元組是否為一個字元編碼的第一個位元組；根據前四位（如果前兩位均為1），可確定該位元組為字元編碼的第一個位元組，並且可判斷對應的字元由幾個位元組表示；根據前五位（如果前四位為1），可判斷編碼是否有錯誤或資料傳輸過程中是否有錯誤。
</p>, <p>UTF-8的設計有以下的多字元組序列的特質：
</p>, <p>UTF-8的這些特質，保證了一個字元的<a href="/wiki/%E5%AD%97%E8%8A%82" title="位元組">位元組</a>序列不會包含在另一個字元的<a href="/wiki/%E5%AD%97%E8%8A%82" title="位元組">位元組</a>序列中。這確保了以位元組為基礎的部份字串比對（sub-string match）方法可以適用於在文字中搜尋字或詞。有些比較舊的可變長度8位元編碼（如<a href="/wiki/Shift_JIS" title="Shift JIS">Shift JIS</a>）沒有這個特質，故字串比對的演算法變得相當複雜。雖然這增加了UTF-8編碼的字串的<a href="/wiki/%E4%BF%A1%E6%81%AF%E5%86%97%E4%BD%99" title="資訊冗餘">資訊冗餘</a>，但是利多於弊。另外，<a class="mw-redirect" href="/wiki/%E8%B3%87%E6%96%99%E5%A3%93%E7%B8%AE" title="資料壓縮">資料壓縮</a>並非Unicode的目的，所以不可混為一談。即使在傳送過程中有部份位元組因錯誤或干擾而完全遺失，還是有可能在下一個字元的起點重新同步，令受損範圍受到限制。
</p>, <p>另一方面，由於其位元組序列設計，如果一個疑似為字串的序列被驗證為UTF-8編碼，那麼我們可以有把握地說它是UTF-8字串。一段兩位元組隨機序列碰巧為合法的UTF-8而非ASCII的機率為32分1。對於三位元組序列的機率為256分1，對更長的序列的機率就更低了。
</p>, <p>UTF-8是UNICODE的一種變長度的編碼表達方式〈一般UNICODE為雙位元組（指UCS2）〉，它由<a href="/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A" title="肯·湯普遜">肯·湯普遜</a><small>（<span lang="en">Ken Thompson</span>）</small>於1992年建立，現在已經標準化為RFC 3629。UTF-8就是以8位元為單元對UCS進行編碼，而UTF-8不使用大尾序和小尾序的形式，每個使用UTF-8儲存的字元，除了第一個位元組外，其餘位元組的頭兩個位元都是以"10"開始，使文字處理器能夠較快地找出每個字元的開始位置。
</p>, <p>但為了與以前的ASCII碼相容（ASCII為一個位元組），因此UTF-8選擇了使用可變長度<a href="/wiki/%E5%AD%97%E8%8A%82" title="位元組">位元組</a>來儲存Unicode：
</p>, <p>(注意：不論是Unicode (Table 3.7) <sup class="reference" id="cite_ref-12"><a href="#cite_note-12">[12]</a></sup>, 還是ISO 10646 (10.2 UTF-8) <sup class="reference" id="cite_ref-13"><a href="#cite_note-13">[13]</a></sup>, 目前都只規定了最高碼位是0x10FFFF的字元的編碼，下表中表示大於0x10FFFF的UTF-8編碼是不符合標準的。)
</p>, <p>ASCII字母繼續使用1位元組儲存，<a class="new" href="/w/index.php?title=%E9%87%8D%E9%9F%B3%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1" title="重音文字（頁面不存在）">重音文字</a>、<a class="mw-redirect" href="/wiki/%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D" title="希臘字母">希臘字母</a>或<a class="mw-redirect" href="/wiki/%E8%A5%BF%E9%87%8C%E7%88%BE%E5%AD%97%E6%AF%8D" title="西里爾字母">西里爾字母</a>等使用2位元組來儲存，而常用的<a class="mw-redirect" href="/wiki/%E6%BC%A2%E5%AD%97" title="漢字">漢字</a>就要使用3位元組。<a class="mw-redirect" href="/wiki/%E8%BE%85%E5%8A%A9%E5%B9%B3%E9%9D%A2" title="輔助平面">輔助平面</a>字元則使用4位元組。
</p>, <p>在UTF-8+BOM格式檔案的開首，很多時都放置一個U+FEFF字元（UTF-8以EF,BB,BF代表），以顯示這個文字檔案是以UTF-8編碼。
</p>, <p>總體來說，在Unicode字串中不可能由碼點數量決定顯示它所需要的長度，或者顯示字串之後在文字緩衝區中游標應該放置的位置；組合字元、變寬字型、不可列印字元和從右至左的文字都是其歸因。
</p>, <p>所以儘管在UTF-8字串中字元數量與碼點數量的關係比UTF-32更為複雜，在實際中很少會遇到有不同的情形。
</p>, <p>更詳細的說，UTF-8編碼具有以下幾點優點：
</p>, <p>一份寫得很差（並且與目前標準的版本不相容）的UTF-8<a class="mw-redirect" href="/wiki/%E8%A7%A3%E6%9E%90%E5%99%A8" title="解析器">解析器</a>可能會接受一些不同的偽UTF-8表示並將它們轉換到相同的Unicode輸出上。這為設計用於處理八位表示的校驗常式提供了一種遺漏資訊的方式。
</p>, <p><a href="/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="正規表示式">正規表示式</a>可以進行很多英文進階的模糊檢索。例如，[a-h]表示a到h間所有字母。
</p>, <p>同樣GBK編碼的中文也可以這樣利用<a href="/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="正規表示式">正規表示式</a>，比如在只知道一個字的讀音而不知道怎麼寫的情況下，也可用<a href="/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="正規表示式">正規表示式</a>檢索，因為GBK編碼是按讀音排序的。但是UTF-8不是按讀音排序的，所以不利於用正規表示式檢索（雖然正規表示式檢索並未考慮中文中的多音字，但是由於中文的多音字數量不多，不少多音字還是同音不同調類型的多音字，所以大多數情況下正規表示式檢索是可以接受的）。但是，Unicode是按部首排序的，因此在只知道一個字的部首而不知道如何發音的情況下，UTF-8可用<a href="/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="正規表示式">正規表示式</a>檢索而GBK不行。
</p>, <p>與其他Unicode編碼相比，特別是UTF-16，在UTF-8中ASCII字元佔用的空間只有一半，可是在一些字元的UTF-8編碼佔用的空間就要多出1/3，特別是中文、日文和韓文（<a class="mw-redirect" href="/wiki/CJK" title="CJK">CJK</a>）這樣的方塊文字。
</p>, <p>雖然不是標準，但許多Windows程式（包括Windows記事本）在UTF-8編碼的檔案的開首加入一段位元組串<code>EF BB BF</code>。這是<a href="/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F" title="位元組順序記號">位元組順序記號</a><code>U+FEFF</code>的UTF-8編碼結果。對於沒有預期要處理UTF-8的文字編輯器和瀏覽器會顯示成ISO-8859-1字串<code>ï»¿</code>。
</p>, <p>Posix系統明確不建議使用位元組序遮罩<code>EF BB BF</code>。<sup class="reference" id="cite_ref-faq_14-0"><a href="#cite_note-faq-14">[14]</a></sup>因為很多文字檔案期望以 「#!」（<a href="/wiki/Shebang" title="Shebang">Shebang</a>）開頭指示要執行的程式。Linux系統選擇使用Unicode規範形式Normalization Form C（NFC），即優先使用預組裝字元（precomposed character）而非組合字元序列（combining character sequence）。
</p>, <p>2002年9月發布的<a href="/wiki/Red_Hat_Linux" title="Red Hat Linux">Red Hat Linux 8.0</a>才開始正式把大多數<a href="/wiki/%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE" title="區域設定">區域設定</a>的預設編碼設為UTF-8。此前是各種語言的但位元組編碼為主。2004年9月<a class="mw-redirect" href="/wiki/SuSE_Linux" title="SuSE Linux">SuSE Linux 9.1</a>開始，預設編碼遷移為UTF-8。
</p>, <p>字串處理時，使用UTF-8或locale依賴的多位元組編碼情形，比使用C語言wchar_t的寬字元固定寬度編碼，要慢1至2個數量級。<sup class="reference" id="cite_ref-faq_14-1"><a href="#cite_note-faq-14">[14]</a></sup>
</p>, <p>在通常用法下，<a href="/wiki/Java" title="Java">Java</a>程式語言在通過<code><a class="external text" href="http://download.oracle.com/javase/7/docs/api/java/io/InputStreamReader.html" rel="nofollow">InputStreamReader</a></code>和<code><a class="external text" href="http://download.oracle.com/javase/7/docs/api/java/io/OutputStreamWriter.html" rel="nofollow">OutputStreamWriter</a></code>讀取和寫入串的時候支援標準UTF-8。但是，Java也支援一種非標準的變體UTF-8，供物件的<a href="/wiki/%E5%BA%8F%E5%88%97%E5%8C%96" title="序列化">序列化</a>，<a class="new" href="/w/index.php?title=Java%E6%9C%AC%E5%9C%B0%E7%95%8C%E9%9D%A2&amp;action=edit&amp;redlink=1" title="Java本地介面（頁面不存在）">Java本地介面</a>和在class檔案中的嵌入常數時使用的<code><a class="external text" href="http://download.oracle.com/javase/7/docs/api/java/io/DataInput.html#modified-utf-8" rel="nofollow">modified UTF-8</a></code>。
</p>, <p>標準和變種的UTF-8有兩個不同點。第一，<a href="/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6" title="空字元">空字元</a>（null character，U+0000）使用雙位元組的0xc0 0x80，而不是單位元組的0x00。這保證了在已編碼字串中沒有嵌入空位元組。因為<a href="/wiki/C%E8%AF%AD%E8%A8%80" title="C語言">C語言</a>等語言程式中，單位元組空字元是用來標誌字串結尾的。當已編碼字串放到這樣的語言中處理，一個嵌入的空字元將把字串一刀兩斷。
</p>, <p>第二個不同點是<a class="mw-redirect" href="/wiki/%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A8%AE%E5%B9%B3%E9%9D%A2" title="基本多文種平面">基本多文種平面</a>之外字元的編碼的方法。在標準UTF-8中，這些字元使用4位元組形式編碼，而在修正的UTF-8中，這些字元和UTF-16一樣首先表示為代理對（surrogate pairs），然後再像<a class="new" href="/w/index.php?title=CESU-8&amp;action=edit&amp;redlink=1" title="CESU-8（頁面不存在）">CESU-8</a>那樣按照代理對分別編碼。這樣修正的原因更是微妙。Java中的字元為16位元長，因此一些Unicode字元需要兩個Java字元來表示。語言的這個性質蓋過了Unicode的增補平面的要求。儘管如此，為了要保持良好的向下相容、要改變也不容易了。這個修正的編碼系統保證了一個已編碼字串可以一次編為一個UTF-16碼，而不是一次一個Unicode碼點。不幸的是，這也意味著UTF-8中需要4位元組的字元在變種UTF-8中變成需要6位元組。
</p>, <p>因為變種UTF-8並<b>不是</b>UTF-8，所以用戶在交換資訊和使用網際網路的時候需要特別注意不要誤把變種UTF-8當成UTF-8資料。
</p>, <p><a class="mw-redirect" href="/wiki/Mac_OS_X" title="Mac OS X">Mac OS X</a><a href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" title="作業系統">作業系統</a>使用正式分解萬國碼（canonically decomposed Unicode），在<a href="/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" title="檔案系統">檔案系統</a>中使用UTF-8編碼進行檔案命名，這做法通常被稱為UTF-8-MAC。正式分解萬國碼中，預組合字元是被禁止使用的，必須以<a href="/wiki/%E7%B5%84%E5%90%88%E5%AD%97%E7%AC%A6" title="組合字元">組合字元</a>取代。
</p>, <p>這種方法使分類變得非常簡單，但是會搞混那些使用預組合字元為標準、組合字元用來顯示特殊字元的軟體。Mac系統的這種NFD資料是<a class="new" href="/w/index.php?title=%E4%B8%87%E5%9B%BD%E7%A0%81%E8%A7%84%E8%8C%83%E5%8C%96&amp;action=edit&amp;redlink=1" title="萬國碼規格化（頁面不存在）">萬國碼規格化</a>（Unicode normalization）的一種格式。而其他系統，包括<a class="mw-redirect" href="/wiki/Windows" title="Windows">Windows</a>和<a href="/wiki/Linux" title="Linux">Linux</a>，使用萬國碼規範的NFC形式，也是<a class="mw-redirect" href="/wiki/W3C" title="W3C">W3C</a>標準使用的形式。所以通常NFD資料必須轉換成NFC才能被其他平台或者網路使用。
</p>, <p>蘋果開發者專區有關於此問題的討論：<a class="external text" href="http://developer.apple.com/qa/qa2001/qa1173.html" rel="nofollow">Apple Q&amp;A 1173</a>。
</p>]