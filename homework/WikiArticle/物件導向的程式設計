[<p><b>物件導向程式設計</b>（英語：<span lang="en">Object-oriented programming</span>，<a class="mw-redirect" href="/wiki/%E7%BC%A9%E5%86%99" title="縮寫">縮寫</a>：<span lang="en">OOP</span>）是種具有<a href="/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="物件 (電腦科學)">物件</a>概念的<a href="/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B" title="程式設計範型">程式程式設計典範</a>，同時也是一種程式開發的抽象方針。它可能包含<a href="/wiki/%E6%95%B0%E6%8D%AE" title="資料">資料</a>、<span class="ilh-all" data-foreign-title="Attribute (computing)" data-lang-code="en" data-lang-name="英語" data-orig-title="属性 (计算机科学)"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E5%B1%9E%E6%80%A7_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&amp;action=edit&amp;redlink=1" title="屬性 (電腦科學)（頁面不存在）">屬性</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Attribute_(computing)" title="en:Attribute (computing)"><span dir="auto" lang="en">Attribute (computing)</span></a></span>）</span></span>、<a href="/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81" title="原始碼">程式碼</a>與<a href="/wiki/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" title="方法 (電腦科學)">方法</a>。物件則指的是<a href="/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="類別 (電腦科學)">類別</a>的實例。它將<a class="mw-redirect" href="/wiki/%E7%89%A9%E4%BB%B6_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" title="物件 (電腦科學)">物件</a>作為<a href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F" title="電腦程式">程式</a>的基本單元，將程式和<a href="/wiki/%E6%95%B0%E6%8D%AE" title="資料">資料</a><a href="/wiki/%E5%B0%81%E8%A3%9D_(%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)" title="封裝 (物件導向程式設計)">封裝</a>其中，以提高軟體的重用性、靈活性和擴充性，物件裡的程式可以存取及經常修改物件相關連的資料。在物件導向程式程式設計裡，電腦程式會被設計成彼此相關的物件<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup><sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup>。
</p>, <p>物件導向程式設計可以看作一種在程式中包含各種獨立而又互相呼叫的物件的思想，這與傳統的思想剛好相反：傳統的程式設計主張將程式看作一系列<a href="/wiki/%E5%87%BD%E6%95%B0" title="函式">函式</a>的集合，或者直接就是一系列對電腦下達的指令。物件導向程式設計中的每一個物件都應該能夠接受資料、處理資料並將資料傳達給其它物件，因此它們都可以被看作一個小型的「機器」，即物件。目前已經被證實的是，物件導向程式設計推廣了程式的靈活性和可維護性，並且在大型專案設計中廣為應用。此外，支持者聲稱物件導向程式設計要比以往的做法更加便於學習，因為它能夠讓人們更簡單地設計並維護程式，使得程式更加便於分析、設計、理解。反對者在某些領域對此予以否認。
</p>, <p>當我們提到物件導向的時候，它不僅指一種程式設計方法。它更多意義上是一種程式開發方式。在這一方面，我們必須了解更多關於<a class="mw-redirect" href="/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90" title="物件導向系統分析">物件導向系統分析</a>和<a href="/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1" title="物件導向設計">物件導向設計</a>（Object Oriented Design，簡稱OOD）方面的知識。許多流行的程式語言是物件導向的,它們的風格就是會透由物件來創出實例。
</p>, <p>重要的物件導向程式語言包含<a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a>、<a href="/wiki/Python" title="Python">Python</a>、<a href="/wiki/C%2B%2B" title="C++">C++</a>、<a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>、<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>、<a href="/wiki/Delphi" title="Delphi">Delphi</a>、<a href="/wiki/Java" title="Java">Java</a>、<a href="/wiki/Swift_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" title="Swift (程式語言)">Swift</a>、<a href="/wiki/C%E2%99%AF" title="C♯">C#</a>、<a href="/wiki/Perl" title="Perl">Perl</a>、<a href="/wiki/Ruby" title="Ruby">Ruby</a> 與 <a href="/wiki/PHP" title="PHP">PHP</a>等。
</p>, <p>物件導向程式程式設計的定義是使用「物件」來做設計，但並非所有的程式語言都直接支援「物件導向程式程式設計」相關技術與結構。對於OOP的準確定義及其本意存在著不少爭論。通常，OOP被理解為一種將程式分解為封裝資料及相關操作的模組而進行的程式設計方式。有別於其它程式設計方式，OOP中的與某資料類別型相關的一系列操作都被有機地封裝到該資料類別型當中，而非散放於其外，因而OOP中的資料類別型不僅有著狀態，還有著相關的行為。
</p>, <p>OOP理論，及與之同名的OOP實踐相結合創造出了新的一個程式設計架構；OOP思想被廣泛認為是非常有用的，以致一套新的<a href="/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B" title="程式設計範型">程式設計範型</a>被創造了出來。（其它的<a href="/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B" title="程式設計範型">程式設計範型</a>例如函式語言程式設計或程序式程式設計專注於程式執行的過程，而邏輯程式設計專注於引發程式碼執行的斷言）。對面向類比系統的語言（如：SIMULA 67）的研究及對高可靠性系統架構（如：高效能作業系統和CPU的架構）的研究最終導致了OOP的誕生。其中由<a class="new" href="/w/index.php?title=Deborah_J._Armstrong&amp;action=edit&amp;redlink=1" title="Deborah J. Armstrong（頁面不存在）">Deborah J. Armstrong</a>進行的長達40年之久的電腦著作調查中，顯示出了一系列物件導向程式設計的基本理論。物件導向程式特徵被條列如下<sup class="reference" id="cite_ref-ArmstrongQuarks_3-0"><a href="#cite_note-ArmstrongQuarks-3">[3]</a></sup><sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup><sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup><sup class="reference" id="cite_ref-pierce_6-0"><a href="#cite_note-pierce-6">[6]</a></sup>
</p>, <p>物件導向程式設計通常共享高階程式語言的低階功能。可用於建構一個程式的基本工具包括：
</p>, <p>支援物件導向程式語言通常利用<a href="/wiki/%E7%BB%A7%E6%89%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="繼承 (電腦科學)">繼承</a>其他類達到代碼重用和可擴展性的特性。而類有兩個主要的概念：
</p>, <p>其中<a href="/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="類別 (電腦科學)">類別</a>（Class）定義了一件事物的抽象特點。類別的定義包含了資料的形式以及對資料的操作。舉例來說，「<a class="mw-redirect" href="/wiki/%E7%8B%97" title="狗">狗</a>」這個類別會包含狗的一切基礎特徵，即所有「狗」都共有的特徵或行為，例如它的孕育、毛皮顏色和吠叫的能力。類別可以為程式提供模版和結構。一個類別的方法和屬性被稱為「<a class="new" href="/w/index.php?title=%E6%88%90%E5%91%98&amp;action=edit&amp;redlink=1" title="成員（頁面不存在）">成員</a>」。
我們來看一段<a href="/wiki/%E4%BC%AA%E4%BB%A3%E7%A0%81" title="虛擬碼">虛擬碼</a>：
</p>, <p>在這串代碼中，我們聲明了一個類別，這個類別具有一些狗的基本特徵。關於<a class="new" href="/w/index.php?title=%E5%85%AC%E6%9C%89%E6%88%90%E5%91%98&amp;action=edit&amp;redlink=1" title="公有成員（頁面不存在）">公有成員</a>和<a class="new" href="/w/index.php?title=%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98&amp;action=edit&amp;redlink=1" title="私有成員（頁面不存在）">私有成員</a>，請參見下面的繼承性的內容。
</p>, <p><a href="/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="物件 (電腦科學)">物件</a>（Object）是類別的<a class="mw-redirect" href="/wiki/%E5%AE%9E%E4%BE%8B" title="實例">實例</a>。物件有時會對應到現實世界中的事物，舉例來說，一個圖形程式可能有圓形、矩形與畫面等物件，一個線上購物系統可能有購物車、顧客與產品等類別。<sup class="reference" id="cite_ref-7"><a href="#cite_note-7">[7]</a></sup>。有時物件會表示更抽象的實體，比如一個被開啟的檔案或是一個提供美國慣用量測轉換的服務。每個物件就是一個特定類別的實例（例如，名稱是「瑪麗」的物件可能是類別雇員的一個實例）。程式在物件導向程式設計當中被視為方法，變數被視為成員或屬性。例如，「<a class="mw-redirect" href="/wiki/%E7%8B%97" title="狗">狗</a>」這個類別列舉狗的特點，從而使這個類別定義了世界上所有的狗。而萊絲這個物件則是一條具體的狗，它的屬性也是具體的。狗有皮毛顏色，而萊絲的皮毛顏色是棕白色的。因此，萊絲就是狗這個類別的一個實例。一個具體物件屬性的值被稱作它的「<a class="mw-disambig" href="/wiki/%E7%8A%B6%E6%80%81" title="狀態">狀態</a>」。（系統給物件分配記憶體空間，而不會給類別分配記憶體空間。這很好理解，類別是抽象的，系統不可能給抽象的東西分配空間，而物件則是具體的。）
</p>, <p>假設我們已經在上面定義了狗這個類別，我們就可以用這個類別來定義物件：
</p>, <p>我們無法讓狗這個類別去吠叫，但是我們可以讓物件「萊絲」去吠叫，正如狗可以吠叫，但沒有具體的狗就無法吠叫。
</p>, <p>類別和物件就好比是「實型」和「1.23」，「實型」是一種資料的類別型，而「1.23」是一個真正的「實數」（即物件）。所有的「實數」都具有「實型」所描訴的特徵，如「實數的大小」，系統則分配記憶體給「實數」儲存具體的數值。
</p>, <p>定義上<a class="new" href="/w/index.php?title=%E5%8B%95%E6%85%8B%E9%85%8D%E7%BD%AE&amp;action=edit&amp;redlink=1" title="動態組態（頁面不存在）">動態組態</a>是指方法會隨著實例動態的改變。而<a href="/wiki/%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E_(%E8%BB%9F%E9%AB%94)" title="訊息傳遞 (軟體)">訊息傳遞機制</a>（Message Passing）是指一個物件通過接受訊息、處理訊息、傳出訊息或使用其他類別的方法來實作一定功能。如：<b>萊絲</b>可以通過<b>吠叫</b>引起<b>人</b>的注意，從而導致一系列的事發生。
</p>, <p>具備<a href="/wiki/%E5%B0%81%E8%A3%9D_(%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)" title="封裝 (物件導向程式設計)">封裝性</a>（Encapsulation）的物件導向程式設計隱藏了某一方法的具體執行步驟，取而代之的是通過訊息傳遞機制傳送訊息給它。封裝是通過限制只有特定類別的物件可以存取這一特定類別的成員，而它們通常利用介面實作訊息的傳入傳出。舉個例子，介面能確保幼犬這一特徵只能被賦予狗這一類別。通常來說，成員會依它們的存取權限被分為3種：<a class="new" href="/w/index.php?title=%E5%85%AC%E6%9C%89%E6%88%90%E5%93%A1&amp;action=edit&amp;redlink=1" title="公有成員（頁面不存在）">公有成員</a>、<a class="new" href="/w/index.php?title=%E7%A7%81%E6%9C%89%E6%88%90%E5%93%A1&amp;action=edit&amp;redlink=1" title="私有成員（頁面不存在）">私有成員</a>以及<a class="new" href="/w/index.php?title=%E4%BF%9D%E8%AD%B7%E6%88%90%E5%93%A1&amp;action=edit&amp;redlink=1" title="保護成員（頁面不存在）">保護成員</a>。有些語言更進一步：<a href="/wiki/Java" title="Java">Java</a>可以限制同一包內不同類別的存取；<a href="/wiki/C%E2%99%AF" title="C♯">C#</a>和<a class="mw-redirect" href="/wiki/VB.NET" title="VB.NET">VB.NET</a>保留了為類別的成員聚集準備的關鍵字：internal（C#）和Friend（VB.NET）；Eiffel語言則可以讓使用者指定哪個類別可以存取所有成員。
</p>, <p>具備<a href="/wiki/%E5%B0%81%E8%A3%9D_(%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)" title="封裝 (物件導向程式設計)">封裝性</a>（Encapsulation）的物件導向程式設計隱藏了某一方法的具體執行步驟，取而代之的是通過訊息傳遞機制傳送訊息給它。因此，舉例來說，「狗」這個類別有「吠叫()」的方法，這一方法定義了狗具體該通過什麼方法吠叫。但是，萊絲的朋友並不知道它到底是如何吠叫的。
</p>, <p>從實例來看：
</p>, <p><a class="mw-redirect" href="/wiki/%E7%BB%A7%E6%89%BF%E6%80%A7" title="繼承性">繼承性</a>（Inheritance）是指，在某種情況下，一個類別會有「<a class="mw-redirect" href="/wiki/%E5%AD%90%E7%B1%BB" title="子類別">子類別</a>」。子類別比原本的類別（稱為<a class="new" href="/w/index.php?title=%E7%88%B6%E7%B1%BB&amp;action=edit&amp;redlink=1" title="父類別（頁面不存在）">父類別</a>）要更加具體化。例如，「<a class="mw-redirect" href="/wiki/%E7%8B%97" title="狗">狗</a>」這個類別可能會有它的<a class="mw-redirect" href="/wiki/%E5%AD%90%E7%B1%BB" title="子類別">子類別</a>「<a class="new" href="/w/index.php?title=%E7%89%A7%E7%BE%8A%E7%8B%97&amp;action=edit&amp;redlink=1" title="牧羊狗（頁面不存在）">牧羊犬</a>」和「<a href="/wiki/%E5%90%89%E5%A8%83%E5%A8%83" title="吉娃娃">吉娃娃犬</a>」。在這種情況下，「萊絲」可能就是牧羊犬的一個<a class="mw-redirect" href="/wiki/%E5%AE%9E%E4%BE%8B" title="實例">實例</a>。子類別會繼承父類別的<span class="ilh-all" data-foreign-title="Attribute (computing)" data-lang-code="en" data-lang-name="英語" data-orig-title="属性 (计算机科学)"><span class="ilh-page"><a class="new" href="/w/index.php?title=%E5%B1%9E%E6%80%A7_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&amp;action=edit&amp;redlink=1" title="屬性 (電腦科學)（頁面不存在）">屬性</a></span><span class="noprint ilh-comment">（<span class="ilh-lang">英語</span><span class="ilh-colon">：</span><span class="ilh-link"><a class="extiw" href="https://en.wikipedia.org/wiki/Attribute_(computing)" title="en:Attribute (computing)"><span dir="auto" lang="en">Attribute (computing)</span></a></span>）</span></span>和<a class="mw-redirect" href="/wiki/%E8%A1%8C%E4%B8%BA" title="行為">行為</a>，並且也可包含它們自己的。我們假設「狗」這個類別有一個<a class="mw-redirect" href="/wiki/%E6%96%B9%E6%B3%95_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="方法 (電腦科學)">方法</a>（行為）叫做「吠叫()」和一個屬性叫做「毛皮顏色」。它的子類別（前例中的牧羊犬和吉娃娃犬）會繼承這些成員。這意味著程式設計師只需要將相同的代碼寫一次。
</p>, <p>在虛擬碼中我們可以這樣寫：
</p>, <p>回到前面的例子，「牧羊犬」這個類別可以繼承「毛皮顏色」這個屬性，並指定其為棕白色。而「吉娃娃犬」則可以繼承「吠叫()」這個方法，並指定它的音調高於平常。子類別也可以加入新的成員，例如，「吉娃娃犬」這個類別可以加入一個方法叫做「顫抖()」。設若用「牧羊犬」這個類別定義了一個實例「萊絲」，那麼萊絲就不會顫抖，因為這個方法是屬于吉娃娃犬的，而非牧羊犬。事實上，我們可以把繼承理解為「是」或「屬於」。萊絲「是」牧羊犬，牧羊犬「屬於」狗類別。因此，萊絲既得到了牧羊犬的屬性，又繼承了狗的屬性。
我們來看虛擬碼：
</p>, <p>當一個類別從多個父類別繼承時，我們稱之為「<a href="/wiki/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" title="多重繼承">多重繼承</a>」。如一隻狗既是吉娃娃犬又是牧羊犬（雖然事實上並不合邏輯）。多重繼承並不總是被支援的，因為它很難理解，又很難被好好使用。
</p>, <p><a class="mw-redirect" href="/wiki/%E5%A4%9A%E5%9E%8B_(%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)" title="多型 (物件導向程式設計)">多型</a>（Polymorphism）是指由繼承而產生的相關的不同的類別，其物件對同一訊息會做出不同的回應<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup>。例如，狗和雞都有「叫()」這一方法，但是呼叫狗的「叫()」，狗會吠叫；呼叫雞的「叫()」，雞則會啼叫。
我們將它體現在虛擬碼上：
</p>, <p>這樣，雖然同樣是做出<b>叫</b>這一種行為，但萊絲和魯斯特具體做出的表現方式將大不相同。多型性的概念可以用在<a href="/wiki/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" title="運算子多載">運算子多載</a>上，可以根據需求檢視相關介面。
</p>, <p><a href="/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" title="抽象化 (計算機科學)">抽象</a>（Abstraction）是簡化複雜的現實問題的途徑，它可以為具體問題找到最恰當的類別定義，並且可以在最恰當的繼承級別解釋問題。舉例說明，萊絲在大多數時候都被當作一條狗，但是如果想要讓它做牧羊犬做的事，你完全可以呼叫牧羊犬的方法。如果狗這個類別還有<a href="/wiki/%E5%8A%A8%E7%89%A9" title="動物">動物</a>的父類別，那麼你完全可以視萊絲為一個動物。
</p>, <p>物件導向程式設計的雛形，早在1960年的<a href="/wiki/Simula" title="Simula">Simula</a>語言中即可發現，當時的<a href="/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" title="程式設計">程式設計</a>領域正面臨著一種危機：在軟硬體環境逐漸複雜的情況下，軟體如何得到良好的維護？物件導向程式設計在某種程度上通過強調<a class="new" href="/w/index.php?title=%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7&amp;action=edit&amp;redlink=1" title="可重複性（頁面不存在）">可重複性</a>解決了這一問題。20世紀70年代的<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk語言</a>在物件導向方面堪稱經典——以至於30年後的今天依然將這一語言視為物件導向語言的基礎。
</p>, <p>電腦科學中物件和實例概念的最早萌芽可以追溯到<a href="/wiki/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2" title="麻省理工學院">麻省理工學院</a>的<a href="/wiki/PDP-1" title="PDP-1">PDP-1</a>系統。這一系統大概是最早的基於容量架構（capability based architecture）的實際系統。另外1963年Ivan Sutherland的<a href="/wiki/Sketchpad" title="Sketchpad">Sketchpad</a>應用中也蘊含了同樣的思想。物件作為程式設計實體最早是於1960年代由<a class="mw-redirect" href="/wiki/Simula_67" title="Simula 67">Simula 67</a>語言引入思維。Simula這一語言是<a href="/wiki/%E5%A5%A7%E5%88%A9-%E7%B4%84%E7%BF%B0%C2%B7%E9%81%94%E7%88%BE" title="奧利-約翰·達爾">奧利-約翰·達爾</a>和<a href="/wiki/%E5%85%8B%E5%88%A9%E6%96%AF%E7%99%BB%C2%B7%E5%A5%88%E5%8A%A0%E7%89%B9" title="克利斯登·奈加特">克利斯登·奈加特</a>在挪威<a class="new" href="/w/index.php?title=%E5%A5%A5%E6%96%AF%E9%99%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%BF%83&amp;action=edit&amp;redlink=1" title="奧斯陸電腦中心（頁面不存在）">奧斯陸電腦中心</a>為類比環境而設計的。（據說，他們是為了類比船隻而設計的這種語言，並且對不同船隻間屬性的相互影響感興趣。他們將不同的船隻歸納為不同的類別，而每一個物件，基於它的類別，可以定義它自己的屬性和行為。）這種辦法是分析式程式的最早概念體現。在分析式程式中，我們將真實世界的物件對映到抽象的物件，這叫做「類比」。Simula不僅引入了「類別」的概念，還應用了實例這一思想——這可能是這些概念的最早應用。
</p>, <p>20世紀70年代<a href="/wiki/%E6%96%BD%E4%B9%90" title="全錄">全錄</a>PARC研究所發明的<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>語言將物件導向程式設計的概念定義為，在基礎運算中，對<a href="/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" title="物件 (電腦科學)">物件</a>和<a class="mw-redirect" href="/wiki/%E6%B6%88%E6%81%AF" title="訊息">訊息</a>的廣泛應用。<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>的建立者深受Simula 67的主要思想影響，但<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>中的物件是完全動態的——它們可以被建立、修改並銷毀，這與Simula中的靜態物件有所區別。此外，<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>還引入了<a class="mw-redirect" href="/wiki/%E7%BB%A7%E6%89%BF%E6%80%A7" title="繼承性">繼承性</a>的思想，它因此一舉超越了不可建立實例的程式設計模型和不具備繼承性的Simula。此外，Simula 67的思想亦被應用在許多不同的語言，如<a class="mw-redirect" href="/wiki/Lisp" title="Lisp">Lisp</a>、<a href="/wiki/Pascal_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" title="Pascal (程式語言)">Pascal</a>。
</p>, <p>物件導向程式設計在80年代成為了一種主導思想，這主要應歸功於<a href="/wiki/C%2B%2B" title="C++">C++</a>——<a href="/wiki/C%E8%AF%AD%E8%A8%80" title="C語言">C語言</a>的擴充版。在<a href="/wiki/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2" title="圖形化使用者介面">圖形化使用者介面</a>（GUI）日漸崛起的情況下，物件導向程式設計很好地適應了潮流。GUI和物件導向程式設計的緊密關聯在Mac OS X中可見一斑。Mac OS X是由<a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>語言寫成的，這一語言是一個仿<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>的C語言擴充版。物件導向程式設計的思想也使<a class="new" href="/w/index.php?title=%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86&amp;action=edit&amp;redlink=1" title="事件處理（頁面不存在）">事件處理</a>式的程式設計更加廣泛被應用（雖然這一概念並非僅存在於物件導向程式設計）。一種說法是，GUI的引入極大地推動了物件導向程式設計的發展。
</p>, <p><a href="/wiki/%E8%8B%8F%E9%BB%8E%E4%B8%96%E8%81%94%E9%82%A6%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2" title="蘇黎世聯邦理工學院">蘇黎世聯邦理工學院</a>的尼克勞斯·維爾特和他的同事們對抽象資料和模組化程式設計進行了研究。Modula-2將這些都包括了進去，而Oberon則包括了一種特殊的物件導向方法——不同於<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>與<a href="/wiki/C%2B%2B" title="C++">C++</a>。
</p>, <p>物件導向的特性也被加入了當時較為流行的語言：<a href="/wiki/Ada" title="Ada">Ada</a>、<a href="/wiki/BASIC" title="BASIC">BASIC</a>、<a class="mw-redirect" href="/wiki/Lisp" title="Lisp">Lisp</a>、<a href="/wiki/Fortran" title="Fortran">Fortran</a>、<a href="/wiki/Pascal_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" title="Pascal (程式語言)">Pascal</a>以及種種。由於這些語言最初並沒有物件導向的設計，故而這種糅合常常會導致相容性和維護性的問題。與之相反的是，「純正的」物件導向語言卻缺乏一些程式設計師們賴以生存的特性。在這一大環境下，開發新的語言成為了當務之急。作為先行者，<a href="/wiki/Eiffel" title="Eiffel">Eiffel</a>成功地解決了這些問題，並成為了當時較受歡迎的語言。
</p>, <p>在過去的幾年中，<a class="mw-redirect" href="/wiki/Java%E8%AF%AD%E8%A8%80" title="Java語言">Java語言</a>成為了廣為應用的語言，除了它與<a href="/wiki/C%E8%AF%AD%E8%A8%80" title="C語言">C</a>和<a href="/wiki/C%2B%2B" title="C++">C++</a>語法上的近似性。Java的可移植性是它的成功中不可磨滅的一步，因為這一特性，已吸引了龐大的程式設計師群的投入。
</p>, <p>在最近的電腦語言發展中，一些既支援物件導向程式設計，又支援<a class="new" href="/w/index.php?title=%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&amp;action=edit&amp;redlink=1" title="程序導向程式設計（頁面不存在）">程序導向程式設計</a>的語言悄然浮出水面。它們中的佼佼者有<a href="/wiki/Python" title="Python">Python</a>、<a href="/wiki/Ruby" title="Ruby">Ruby</a>等等。
</p>, <p>正如<a class="new" href="/w/index.php?title=%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&amp;action=edit&amp;redlink=1" title="程序導向程式設計（頁面不存在）">程序導向程式設計</a>使得<a class="mw-redirect" href="/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" title="結構化程式設計">結構化程式設計</a>的技術得以提升，現代的物件導向程式設計方法使得對<a href="/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" title="設計模式 (電腦)">設計模式</a>的用途、<a href="/wiki/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1" title="契約式設計">契約式設計</a>和<a href="/wiki/%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80" title="建模語言">建模語言</a>（如<a class="mw-redirect" href="/wiki/UML" title="UML">UML</a>）技術也得到了一定提升。
</p>, <p>支援部分或絕大部分物件導向特性的語言即可稱為基於物件的或物件導向的語言。<a href="/wiki/Simula" title="Simula">Simula</a> (1967)被視為第一個具有物件導向特性的語言。早期，完全物件導向的語言主要包括<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>等語言，目前較為流行的語言中有<a href="/wiki/Java" title="Java">Java</a>、<a class="mw-redirect" href="/wiki/C_Sharp" title="C Sharp">C#</a>、<a href="/wiki/Eiffel" title="Eiffel">Eiffel</a>等。隨著軟體工業的發展，比較早的程序導向的語言在近些年的發展中也紛紛吸收了許多物件導向的概念，比如<a href="/wiki/C%E8%AF%AD%E8%A8%80" title="C語言">C</a>→<a href="/wiki/C%2B%2B" title="C++">C++</a>，C→<a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>，<a href="/wiki/BASIC" title="BASIC">BASIC</a>→<a href="/wiki/Visual_Basic" title="Visual Basic">Visual Basic</a>→<a href="/wiki/Visual_Basic_.NET" title="Visual Basic .NET">Visual Basic .NET</a>，<a href="/wiki/Pascal_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" title="Pascal (程式語言)">Pascal</a>→<a href="/wiki/Object_Pascal" title="Object Pascal">Object Pascal</a>，<a href="/wiki/Ada" title="Ada">Ada</a>→<a class="new" href="/w/index.php?title=Ada95&amp;action=edit&amp;redlink=1" title="Ada95（頁面不存在）">Ada95</a>。「純粹」的物件導向語言, 因為所有的東西都是由物件所組成，例如：<a class="new" href="/w/index.php?title=Eiffel_(programming_language)&amp;action=edit&amp;redlink=1" title="Eiffel (programming language)（頁面不存在）">Eiffel</a>, <a class="new" href="/w/index.php?title=Emerald_(programming_language)&amp;action=edit&amp;redlink=1" title="Emerald (programming language)（頁面不存在）">Emerald</a>,<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup> <a class="new" href="/w/index.php?title=JADE_(programming_language)&amp;action=edit&amp;redlink=1" title="JADE (programming language)（頁面不存在）">JADE</a>, <a class="new" href="/w/index.php?title=Obix_programming_language&amp;action=edit&amp;redlink=1" title="Obix programming language（頁面不存在）">Obix</a>, <a class="new" href="/w/index.php?title=Ruby_(programming_language)&amp;action=edit&amp;redlink=1" title="Ruby (programming language)（頁面不存在）">Ruby</a>, <a class="new" href="/w/index.php?title=Scala_(programming_language)&amp;action=edit&amp;redlink=1" title="Scala (programming language)（頁面不存在）">Scala</a>, <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>, <a class="new" href="/w/index.php?title=Self_(programming_language)&amp;action=edit&amp;redlink=1" title="Self (programming language)（頁面不存在）">Self</a>.
</p>, <p>近年來，物件導向的程式設計越來越流行於<a href="/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80" title="手稿語言">手稿語言</a>中。<a href="/wiki/Python" title="Python">Python</a>和<a href="/wiki/Ruby" title="Ruby">Ruby</a>是建立在OOP原理的指令碼語言，<a href="/wiki/Perl" title="Perl">Perl</a>和<a href="/wiki/PHP" title="PHP">PHP</a>亦分別在Perl 5和PHP 4時加入物件導向特性。
</p>]