[<p><b>HTTP管線化</b>（英語：<span lang="en">HTTP pipelining</span>）是將多個<a class="mw-redirect" href="/wiki/HTTP" title="HTTP">HTTP</a>請求（request）整批送出的技術，而在傳送過程中不需先等待伺服器的回應。
</p>, <p>請求結果管線化使得 HTML 網頁載入時間動態提升，特別是在具體有高延遲的連接環境下，如<a href="/wiki/%E5%8D%AB%E6%98%9F%E4%B8%8A%E7%BD%91" title="衛星上網">衛星上網</a>。在寬帶連接中，加速不是那麼顯著的，因為需要伺服器端要遵循 HTTP/1.1 協定，必須按照客戶端傳送的請求順序來回覆請求，這樣整個連接還是先進先出的，<a href="/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" title="隊頭阻塞">隊頭阻塞</a>（HOL blocking）可能會發生，造成延遲。未來的 <a href="/wiki/HTTP/2" title="HTTP/2">HTTP/2.0</a> 或者<a href="/wiki/SPDY" title="SPDY">SPDY</a>中的異步操作將會解決這個問題。因為它可能將多個 HTTP 請求填充在一個<a class="mw-disambig" href="/wiki/TCP" title="TCP">TCP</a>資料包內，HTTP 管線化需要在網路上傳輸較少的 TCP 資料包，減少了網路負載。
</p>, <p>管線化機制須透過永久連線（persistent connection）完成，並且只有 GET 和 HEAD 等要求可以進行管線化，非<a class="mw-redirect" href="/wiki/%E5%B9%82%E7%AD%89" title="冪等">冪等</a>的方法，例如<a class="mw-disambig" href="/wiki/POST" title="POST">POST</a>將不會被管線化。連續的 GET 和 HEAD 請求總可以管線化的。一個連續的冪等請求，如 GET，HEAD，PUT，DELETE，是否可以被管線化取決於一連串請求是否依賴於其他的。此外，初次建立連線時也不應啟動管線機制，因為對方（伺服器）不一定支援 HTTP/1.1 版本的協定。
</p>, <p>HTTP 管線化同時依賴於客戶端和伺服器的支援。遵守 HTTP/1.1 的伺服器支援管線化。這並不是意味著伺服器需要提供管線化的回覆，而只是要求在收到管線化的請求時候不會失敗。
</p>]